<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PepeChat v5.1 路 Zero Trust & Resilient</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  
  <!-- QR Code Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top left, #1a1a1a 0%, #000000 100%);
      --glass-panel: rgba(20, 20, 20, 0.85);
      --glass-border: rgba(255, 255, 255, 0.08);
      --accent: #0A84FF;
      --accent-grad: linear-gradient(135deg, #0A84FF, #0056b3);
      --text-main: #e0e0e0;
      --text-muted: #8e8e93;
      --bubble-in: #262628;
      --bubble-out: #0A84FF;
      --danger: #FF453A;
      --success: #30D158;
      --warning: #FFD60A;
      --radius-lg: 18px;
      --font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0;
      font-family: var(--font-stack);
      background: var(--bg-gradient);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* --- LOGIN SCREEN --- */
    #loginScreen {
      position: absolute; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.9); backdrop-filter: blur(20px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: opacity 0.5s ease;
    }
    #loginScreen.hidden { opacity: 0; pointer-events: none; }
    
    .login-card {
      background: rgba(30,30,30,0.9); padding: 40px; border-radius: 24px;
      border: 1px solid var(--glass-border); text-align: center; width: 90%; max-width: 400px;
    }
    .login-input {
      width: 100%; padding: 14px; border-radius: 12px; border: 1px solid var(--glass-border);
      background: rgba(0,0,0,0.5); color: white; font-size: 16px; outline: none; margin-bottom: 15px;
    }
    .btn-primary {
      width: 100%; padding: 14px; border-radius: 12px; border: none;
      background: var(--accent-grad); color: white; font-weight: 600; font-size: 16px; cursor: pointer;
    }

    /* --- MAIN APP LAYOUT --- */
    #app {
      width: 100%; height: 100%; max-width: 1600px; display: flex;
      background: var(--glass-panel); backdrop-filter: blur(30px);
      box-shadow: 0 0 50px rgba(0,0,0,0.8); opacity: 0; transform: scale(0.98);
      transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    }
    #app.visible { opacity: 1; transform: scale(1); }

    /* SIDEBAR */
    aside {
      width: 320px; border-right: 1px solid var(--glass-border);
      display: flex; flex-direction: column; background: rgba(0,0,0,0.3);
    }
    .sidebar-header { padding: 20px; border-bottom: 1px solid var(--glass-border); }
    .user-profile { display: flex; align-items: center; gap: 10px; }
    .avatar {
      width: 40px; height: 40px; border-radius: 50%;
      background: linear-gradient(45deg, #444, #666);
      display: flex; align-items: center; justify-content: center; font-weight: bold;
    }
    .sidebar-actions { padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .action-btn {
      background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); padding: 10px;
      border-radius: 8px; color: var(--text-main); font-size: 12px; cursor: pointer;
      display: flex; align-items: center; justify-content: center; gap: 6px;
    }
    .action-btn:hover { background: rgba(255,255,255,0.1); }
    
    .chat-list { flex: 1; overflow-y: auto; padding: 10px; }
    .chat-item {
      padding: 12px; border-radius: 10px; cursor: pointer;
      display: flex; align-items: center; gap: 12px; margin-bottom: 5px;
      border: 1px solid transparent;
    }
    .chat-item:hover { background: rgba(255,255,255,0.05); }
    .chat-item.active { background: rgba(10, 132, 255, 0.15); border-color: rgba(10,132,255,0.3); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
    .status-dot.online { background: var(--success); box-shadow: 0 0 8px var(--success); }

    /* CHAT AREA */
    main {
      flex: 1; display: flex; flex-direction: column; position: relative;
      background: rgba(0,0,0,0.2);
    }
    .chat-header {
      padding: 15px 20px; border-bottom: 1px solid var(--glass-border);
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(30,30,30,0.6); backdrop-filter: blur(10px);
    }
    .header-controls { display: flex; gap: 10px; align-items: center; }
    .icon-btn {
      background: transparent; border: none; color: var(--text-muted);
      cursor: pointer; font-size: 16px; padding: 8px; border-radius: 50%;
    }
    .icon-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.1); }
    .icon-btn.active { color: var(--accent); background: rgba(10,132,255,0.15); }
    .icon-btn.danger { color: var(--danger); }

    .messages-container {
      flex: 1; overflow-y: auto; padding: 20px;
      display: flex; flex-direction: column; gap: 8px;
    }
    .msg {
      max-width: 70%; padding: 10px 14px; border-radius: 18px;
      font-size: 14px; line-height: 1.4; position: relative; word-wrap: break-word;
    }
    .msg.in { align-self: flex-start; background: var(--bubble-in); border-bottom-left-radius: 4px; }
    .msg.out { align-self: flex-end; background: var(--bubble-out); border-bottom-right-radius: 4px; color: white; }
    .msg.system { align-self: center; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); font-size: 11px; max-width: 90%; color: var(--text-muted); }
    
    /* Zero Trust Reveal Button */
    .reveal-btn {
      background: rgba(0,0,0,0.3); border: 1px dashed var(--text-muted);
      color: var(--text-muted); padding: 15px; border-radius: 8px;
      cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 8px;
      width: 100%; justify-content: center;
    }
    .reveal-btn:hover { background: rgba(0,0,0,0.5); color: white; border-color: white; }
    .msg img { max-width: 100%; border-radius: 10px; margin-top: 5px; display: block; }

    .msg-meta { font-size: 10px; opacity: 0.7; margin-top: 4px; display: flex; justify-content: flex-end; gap: 6px; align-items: center; }
    .msg-status { font-size: 10px; }
    .ghost-fade { animation: fadeOut 30s forwards; }
    @keyframes fadeOut { 0% { opacity: 1; } 90% { opacity: 0.1; filter: blur(2px); } 100% { opacity: 0; display: none; } }

    /* INPUT AREA */
    .input-area {
      padding: 15px; border-top: 1px solid var(--glass-border);
      display: flex; gap: 10px; align-items: center; background: rgba(30,30,30,0.6);
    }
    .msg-input {
      flex: 1; background: rgba(0,0,0,0.4); border: 1px solid var(--glass-border);
      border-radius: 20px; padding: 10px 15px; color: white; outline: none; font-size: 14px;
    }
    .msg-input:focus { border-color: var(--accent); }
    .file-btn {
      color: var(--accent); background: rgba(10,132,255,0.1); border: none;
      width: 40px; height: 40px; border-radius: 50%; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .file-btn:hover { background: rgba(10,132,255,0.2); }

    /* SECURITY LOG */
    #securityLog {
      height: 30px; overflow: hidden; background: #000; border-top: 1px solid var(--glass-border);
      font-family: monospace; font-size: 10px; color: var(--success);
      transition: height 0.3s; display: flex; flex-direction: column;
    }
    #securityLog.open { height: 150px; }
    .log-header {
      padding: 8px 15px; background: #111; cursor: pointer; display: flex; justify-content: space-between;
    }
    .log-content { padding: 10px; overflow-y: auto; flex: 1; }
    .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; display: flex; gap: 10px; }
    .log-hash { color: #888; user-select: all; }

    /* VIRTUAL KEYBOARD */
    #virtualKeyboard {
      height: 0; overflow: hidden; transition: height 0.3s ease;
      background: #151515; border-top: 1px solid var(--glass-border);
      display: flex; flex-direction: column;
    }
    #virtualKeyboard.open { height: 280px; }
    .vk-toolbar { display: flex; justify-content: space-between; padding: 5px 10px; background: #222; font-size: 12px; }
    .vk-keys { flex: 1; padding: 10px; display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; overflow-y: auto; align-content: start; }
    .vk-key {
      background: #333; color: white; border-radius: 5px; height: 40px;
      display: flex; align-items: center; justify-content: center; cursor: pointer;
      font-size: 16px; user-select: none; box-shadow: 0 2px 0 #000;
    }
    .vk-key:active { transform: translateY(2px); box-shadow: none; }
    .vk-key.space { grid-column: span 6; }
    .vk-key.wide { grid-column: span 2; }

    /* MODALS */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
      z-index: 200; display: flex; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal {
      background: #1c1c1e; border: 1px solid var(--glass-border); border-radius: 20px;
      padding: 25px; width: 90%; max-width: 350px; text-align: center; transform: scale(0.9);
    }
    .modal-overlay.open .modal { transform: scale(1); }
    .modal-actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    .btn-sec { background: rgba(255,255,255,0.1); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; }

    /* Toggle Switch */
    .toggle-row { display: flex; justify-content: space-between; align-items: center; margin: 15px 0; font-size: 14px; }
    .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 34px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent); }
    input:checked + .slider:before { transform: translateX(16px); }

    /* Animations */
    .shake { animation: shake 0.5s; }
    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      70% { transform: translate(3px, 1px) rotate(-1deg); }
      80% { transform: translate(-1px, -1px) rotate(1deg); }
      90% { transform: translate(1px, 2px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    @media (max-width: 768px) {
      aside { position: absolute; z-index: 50; height: 100%; transform: translateX(-100%); transition: transform 0.3s; background: #111; width: 85%; }
      aside.open { transform: translateX(0); }
      .mobile-menu-btn { display: block; }
    }
    @media (min-width: 769px) { .mobile-menu-btn { display: none; } }
    .hidden-file { display: none; }
  </style>
</head>
<body>

  <!-- LOGIN SCREEN -->
  <div id="loginScreen">
    <div class="login-card">
      <div style="font-size: 40px; margin-bottom: 10px;"></div>
      <h1>PepeChat v5.1</h1>
      <p>Zero Trust 路 Resilient 路 Secure</p>
      <form id="loginForm">
        <input type="text" id="customIdInput" class="login-input" placeholder="Choose a Username / ID" autocomplete="off" maxlength="20">
        <button type="submit" class="btn-primary">Start Chatting</button>
        <div style="margin-top: 15px; font-size: 12px; color: #666;">
          Or <a href="#" id="genRandomLink" style="color: var(--accent);">generate random</a>
        </div>
      </form>
    </div>
  </div>

  <!-- MAIN APP -->
  <div id="app">
    <aside id="sidebar">
      <div class="sidebar-header">
        <div class="user-profile">
          <div class="avatar" id="myAvatar">?</div>
          <div class="user-info">
            <h3 id="myNameDisplay">Guest</h3>
            <span id="myIdDisplay" style="font-size:10px; color:#666;">...</span>
            <i class="fa-regular fa-copy" id="copyMyIdBtn" style="cursor:pointer; font-size:12px; margin-left:5px; color:var(--accent);" title="Copy ID"></i>
          </div>
        </div>
      </div>
      
      <div class="sidebar-actions">
        <button class="action-btn" id="showQrBtn"><i class="fa-solid fa-qrcode"></i> QR</button>
        <button class="action-btn" id="addPeerBtn"><i class="fa-solid fa-user-plus"></i> Chat</button>
        <button class="action-btn" id="createGroupBtn"><i class="fa-solid fa-users"></i> Group</button>
        <button class="action-btn" id="settingsBtn"><i class="fa-solid fa-shield-halved"></i> Security</button>
      </div>

      <div class="chat-list" id="chatList"></div>
    </aside>

    <main>
      <div class="chat-header">
        <button class="icon-btn mobile-menu-btn" id="menuBtn"><i class="fa-solid fa-bars"></i></button>
        <div class="chat-meta">
          <h2 id="chatTitle">No Chat Selected</h2>
          <p id="chatStatus">Waiting...</p>
        </div>
        <div class="header-controls">
          <button class="icon-btn" id="ghostToggle" title="Ghost Mode"><i class="fa-solid fa-ghost"></i></button>
          <button class="icon-btn" id="keySettingsBtn" title="Encryption"><i class="fa-solid fa-key"></i></button>
          <button class="icon-btn danger" id="deleteChatBtn" title="Delete/Clear"><i class="fa-solid fa-trash"></i></button>
        </div>
      </div>

      <div class="messages-container" id="messages">
        <div class="msg system">Select a chat or create a group to begin.</div>
      </div>

      <form class="input-area" id="msgForm">
        <button type="button" class="file-btn" id="uploadBtn"><i class="fa-solid fa-paperclip"></i></button>
        <input type="file" id="fileInput" class="hidden-file" multiple>
        <input type="text" class="msg-input" id="msgInput" placeholder="Type message..." autocomplete="off">
        <button type="button" class="file-btn" id="vkToggleBtn" title="Virtual Keyboard"><i class="fa-solid fa-keyboard"></i></button>
        <button type="submit" class="file-btn" id="sendBtn" style="background: var(--accent); color: white;"><i class="fa-solid fa-paper-plane"></i></button>
      </form>

      <!-- SECURITY LOG -->
      <div id="securityLog">
        <div class="log-header" id="logHeader">
          <span><i class="fa-solid fa-terminal"></i> Security Log (Fingerprints)</span>
          <i class="fa-solid fa-chevron-up"></i>
        </div>
        <div class="log-content" id="logContent">
          <div class="log-row">System: Zero Trust Rendering Active.</div>
        </div>
      </div>

      <!-- VIRTUAL KEYBOARD -->
      <div id="virtualKeyboard">
        <div class="vk-toolbar">
          <div class="vk-tabs">
            <div class="vk-tab active" data-set="abc">ABC</div>
            <div class="vk-tab" data-set="123">123</div>
            <div class="vk-tab" data-set="sym">#+=</div>
            <div class="vk-tab" data-set="emo"></div>
          </div>
          <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#888;">
            <input type="checkbox" id="scrambleToggle"> Scramble
          </label>
        </div>
        <div class="vk-keys" id="vkKeys"></div>
      </div>
    </main>
  </div>

  <!-- MODALS -->
  <div class="modal-overlay" id="qrModal">
    <div class="modal">
      <h3>Scan to Connect</h3>
      <div class="qr-container" id="qrCanvas" style="background:white; padding:10px; margin:10px auto; width:fit-content; min-height:200px; min-width:200px;"></div>
      <input type="text" id="shareUrlInput" readonly style="width:100%; background:#333; border:none; color:#888; font-size:10px; padding:5px; margin-bottom:10px;">
      <div class="modal-actions">
        <button class="btn-sec" id="copyLinkBtn">Copy Link</button>
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="addPeerModal">
    <div class="modal">
      <h3>Connect to Peer</h3>
      <input type="text" id="remoteIdInput" class="login-input" placeholder="Enter Peer ID">
      <div class="modal-actions">
        <button class="btn-primary" id="connectSubmitBtn">Connect</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="createGroupModal">
    <div class="modal">
      <h3>Create Group Chat</h3>
      <input type="text" id="groupNameInput" class="login-input" placeholder="Group Name">
      <div class="modal-actions">
        <button class="btn-primary" id="createGroupSubmitBtn">Create</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="groupAddMemberModal">
    <div class="modal">
      <h3>Add Member to Group</h3>
      <input type="text" id="groupMemberIdInput" class="login-input" placeholder="Peer ID to Add">
      <div class="modal-actions">
        <button class="btn-primary" id="groupAddMemberSubmitBtn">Add</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <h3>Security Settings</h3>
      <div class="toggle-row">
        <span>Secure Session (Fingerprint Lock)</span>
        <label class="switch">
          <input type="checkbox" id="secureSessionToggle">
          <span class="slider"></span>
        </label>
      </div>
      <p style="font-size:11px; color:#666; text-align:left;">
        If enabled, peers cannot reconnect with the same ID unless their hardware fingerprint matches the previous session.
      </p>
      <div class="modal-actions">
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="keyModal">
    <div class="modal">
      <h3>Encryption Key</h3>
      <input type="text" id="keyInput" class="login-input" placeholder="Secret Passphrase">
      <div class="modal-actions">
        <button class="btn-primary" id="saveKeyBtn">Update</button>
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // --- CONFIG & STATE ---
      const APP_URL = window.location.href.split('?')[0];
      const STORAGE_KEY = 'pepechat_v5_data';
      
      let peer = null;
      let myId = null;
      let myFingerprint = null;
      let chats = new Map(); 
      let activeChatId = null;
      let ghostMode = false;
      
      let settings = {
        secureSession: false // Default off
      };

      // Virtual Keyboard State
      let vkActive = false;
      let vkSet = 'abc';
      let vkScramble = false;

      // --- DOM ELEMENTS ---
      const els = {
        loginScreen: document.getElementById('loginScreen'),
        loginForm: document.getElementById('loginForm'),
        customIdInput: document.getElementById('customIdInput'),
        genRandomLink: document.getElementById('genRandomLink'),
        app: document.getElementById('app'),
        sidebar: document.getElementById('sidebar'),
        menuBtn: document.getElementById('menuBtn'),
        
        myAvatar: document.getElementById('myAvatar'),
        myNameDisplay: document.getElementById('myNameDisplay'),
        myIdDisplay: document.getElementById('myIdDisplay'),
        copyMyIdBtn: document.getElementById('copyMyIdBtn'),
        chatList: document.getElementById('chatList'),
        
        showQrBtn: document.getElementById('showQrBtn'),
        addPeerBtn: document.getElementById('addPeerBtn'),
        createGroupBtn: document.getElementById('createGroupBtn'),
        settingsBtn: document.getElementById('settingsBtn'),

        chatTitle: document.getElementById('chatTitle'),
        chatStatus: document.getElementById('chatStatus'),
        messages: document.getElementById('messages'),
        msgForm: document.getElementById('msgForm'),
        msgInput: document.getElementById('msgInput'),
        fileInput: document.getElementById('fileInput'),
        uploadBtn: document.getElementById('uploadBtn'),
        vkToggleBtn: document.getElementById('vkToggleBtn'),
        sendBtn: document.getElementById('sendBtn'),
        ghostToggle: document.getElementById('ghostToggle'),
        keySettingsBtn: document.getElementById('keySettingsBtn'),
        deleteChatBtn: document.getElementById('deleteChatBtn'),

        // Logs
        securityLog: document.getElementById('securityLog'),
        logHeader: document.getElementById('logHeader'),
        logContent: document.getElementById('logContent'),

        // VK
        virtualKeyboard: document.getElementById('virtualKeyboard'),
        vkKeys: document.getElementById('vkKeys'),
        vkTabs: document.querySelectorAll('.vk-tab'),
        scrambleToggle: document.getElementById('scrambleToggle'),

        // Modals
        qrModal: document.getElementById('qrModal'),
        qrCanvas: document.getElementById('qrCanvas'),
        shareUrlInput: document.getElementById('shareUrlInput'),
        copyLinkBtn: document.getElementById('copyLinkBtn'),
        
        addPeerModal: document.getElementById('addPeerModal'),
        remoteIdInput: document.getElementById('remoteIdInput'),
        connectSubmitBtn: document.getElementById('connectSubmitBtn'),
        
        createGroupModal: document.getElementById('createGroupModal'),
        groupNameInput: document.getElementById('groupNameInput'),
        createGroupSubmitBtn: document.getElementById('createGroupSubmitBtn'),
        
        groupAddMemberModal: document.getElementById('groupAddMemberModal'),
        groupMemberIdInput: document.getElementById('groupMemberIdInput'),
        groupAddMemberSubmitBtn: document.getElementById('groupAddMemberSubmitBtn'),

        settingsModal: document.getElementById('settingsModal'),
        secureSessionToggle: document.getElementById('secureSessionToggle'),

        keyModal: document.getElementById('keyModal'),
        keyInput: document.getElementById('keyInput'),
        saveKeyBtn: document.getElementById('saveKeyBtn')
      };

      // --- INITIALIZATION ---
      document.addEventListener('DOMContentLoaded', async () => {
        myFingerprint = await generateFingerprint();
        logSecurity(`My Fingerprint Hash: ${myFingerprint.substring(0, 16)}...`);
        
        loadStorage();
        checkUrlParams();
        setupEventListeners();
        renderVk();
      });

      function checkUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const userParam = params.get('user');
        const connectTo = params.get('connect');
        const keyBase64 = params.get('key');

        if (userParam) {
          initApp(userParam, () => {
            if (connectTo) {
              setTimeout(() => {
                let decodedKey = 'changeme';
                if (keyBase64) {
                  try { decodedKey = atob(keyBase64); } catch(e){}
                }
                connectToPeer(connectTo, decodedKey);
                window.history.replaceState({}, document.title, window.location.pathname);
              }, 1000);
            }
          });
        } else if (connectTo) {
          // No user param, generate random
          initApp(generateRandomId(), () => {
             setTimeout(() => {
                let decodedKey = 'changeme';
                if (keyBase64) {
                  try { decodedKey = atob(keyBase64); } catch(e){}
                }
                connectToPeer(connectTo, decodedKey);
                window.history.replaceState({}, document.title, window.location.pathname);
              }, 1000);
          });
        }
      }

      function setupEventListeners() {
        // Login
        els.loginForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const val = els.customIdInput.value.trim().replace(/[^a-zA-Z0-9-_]/g, '');
          if(val) initApp(val);
        });
        els.genRandomLink.addEventListener('click', (e) => {
          e.preventDefault();
          initApp(generateRandomId());
        });

        // Sidebar
        els.menuBtn.addEventListener('click', () => els.sidebar.classList.toggle('open'));
        els.showQrBtn.addEventListener('click', showQrModal);
        els.addPeerBtn.addEventListener('click', () => openModal(els.addPeerModal));
        els.createGroupBtn.addEventListener('click', () => openModal(els.createGroupModal));
        els.settingsBtn.addEventListener('click', () => openModal(els.settingsModal));
        
        els.copyMyIdBtn.addEventListener('click', () => {
          if(myId) {
            navigator.clipboard.writeText(myId);
            els.copyMyIdBtn.classList.remove('fa-copy');
            els.copyMyIdBtn.classList.add('fa-check');
            setTimeout(() => {
              els.copyMyIdBtn.classList.remove('fa-check');
              els.copyMyIdBtn.classList.add('fa-copy');
            }, 1500);
          }
        });

        // Chat Actions
        els.msgForm.addEventListener('submit', (e) => {
          e.preventDefault();
          sendMessage();
        });
        
        // Fallback for Enter key if form submit doesn't trigger
        els.msgInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });

        els.uploadBtn.addEventListener('click', () => els.fileInput.click());
        els.fileInput.addEventListener('change', handleFileUpload);
        
        els.ghostToggle.addEventListener('click', () => {
          ghostMode = !ghostMode;
          els.ghostToggle.classList.toggle('active', ghostMode);
          addSystemMessage(getActiveChat(), ghostMode ? " Ghost Mode ON" : "Ghost Mode OFF");
        });

        els.keySettingsBtn.addEventListener('click', () => {
          const chat = getActiveChat();
          if(!chat) return;
          els.keyInput.value = chat.passphrase;
          openModal(els.keyModal);
        });

        els.deleteChatBtn.addEventListener('click', () => {
          const chat = getActiveChat();
          if(!chat) return;
          if(confirm(chat.type === 'group' ? 'Delete this group and all history?' : 'Clear chat history?')) {
            if(chat.type === 'group') {
              chats.delete(chat.id);
              setActiveChat(null);
            } else {
              chat.messages = [];
              renderMessages(chat);
            }
            saveStorage();
            renderChatList();
          }
        });

        // Logs
        els.logHeader.addEventListener('click', () => {
          els.securityLog.classList.toggle('open');
        });

        // Virtual Keyboard
        els.vkToggleBtn.addEventListener('click', () => {
          vkActive = !vkActive;
          els.virtualKeyboard.classList.toggle('open', vkActive);
          els.vkToggleBtn.style.color = vkActive ? 'var(--accent)' : 'var(--accent)';
        });
        els.vkTabs.forEach(tab => {
          tab.addEventListener('click', () => {
            els.vkTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            vkSet = tab.dataset.set;
            renderVk();
          });
        });
        els.scrambleToggle.addEventListener('change', (e) => {
          vkScramble = e.target.checked;
          renderVk();
        });

        // Modals
        els.connectSubmitBtn.addEventListener('click', () => {
          const id = els.remoteIdInput.value.trim();
          if(id) { connectToPeer(id); closeModals(); }
        });
        els.createGroupSubmitBtn.addEventListener('click', () => {
          const name = els.groupNameInput.value.trim();
          if(name) { createGroup(name); closeModals(); }
        });
        els.groupAddMemberSubmitBtn.addEventListener('click', () => {
          const id = els.groupMemberIdInput.value.trim();
          if(id) { addMemberToGroup(id); closeModals(); }
        });
        els.copyLinkBtn.addEventListener('click', () => {
          els.shareUrlInput.select();
          document.execCommand('copy');
          els.copyLinkBtn.textContent = "Copied!";
          setTimeout(() => els.copyLinkBtn.textContent = "Copy Link", 2000);
        });
        els.saveKeyBtn.addEventListener('click', () => {
          const newKey = els.keyInput.value.trim() || 'changeme';
          const chat = getActiveChat();
          if(chat) {
            chat.passphrase = newKey;
            if(chat.type === 'group') {
              chat.participants.forEach(pid => {
                const conn = chat.connections[pid];
                if(conn && conn.open) conn.send({ kind: 'system', type: 'key_change', text: 'Group key changed.' });
              });
            } else if(chat.conn && chat.conn.open) {
              chat.conn.send({ kind: 'system', type: 'key_change', text: 'Peer changed key.' });
            }
            addSystemMessage(chat, `Key updated: ${newKey}`);
            saveStorage();
            closeModals();
          }
        });
        
        // Settings
        els.secureSessionToggle.addEventListener('change', (e) => {
          settings.secureSession = e.target.checked;
          saveStorage();
          logSecurity(`Secure Session: ${settings.secureSession ? 'ENABLED' : 'DISABLED'}`);
        });
      }

      // --- FINGERPRINTING ---
      async function generateFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = "top";
        ctx.font = "14px 'Arial'";
        ctx.fillStyle = "#f60";
        ctx.fillRect(125,1,62,20);
        ctx.fillStyle = "#069";
        ctx.fillText("PepeChatv5", 2, 15);
        const b64 = canvas.toDataURL();
        
        const components = [
          navigator.userAgent,
          navigator.language,
          new Date().getTimezoneOffset(),
          screen.width + 'x' + screen.height,
          b64
        ];
        
        const str = components.join('||');
        const enc = new TextEncoder();
        const hashBuf = await crypto.subtle.digest('SHA-256', enc.encode(str));
        return buf2hex(hashBuf);
      }

      function logSecurity(msg) {
        const row = document.createElement('div');
        row.className = 'log-row';
        row.innerHTML = `<span class="log-hash">${msg}</span>`;
        els.logContent.appendChild(row);
        els.logContent.scrollTop = els.logContent.scrollHeight;
      }

      // --- VIRTUAL KEYBOARD ---
      const charSets = {
        abc: "qwertyuiopasdfghjklzxcvbnm".split(''),
        '123': "1234567890-/:;()$&@".split(''),
        sym: "[]{}#%^*+=_\\|~<>?!.,".split(''),
        // FIX: Use spread operator to correctly handle emoji surrogate pairs
        emo: [..."○モㄢわ火金"]
      };

      function renderVk() {
        els.vkKeys.innerHTML = '';
        let keys = [...(charSets[vkSet] || [])];
        if(vkScramble) {
          for (let i = keys.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [keys[i], keys[j]] = [keys[j], keys[i]];
          }
        }
        keys.forEach(char => {
          const btn = document.createElement('div');
          btn.className = 'vk-key';
          btn.textContent = char;
          btn.onclick = () => { els.msgInput.value += char; if(vkScramble) renderVk(); };
          els.vkKeys.appendChild(btn);
        });
        const space = document.createElement('div');
        space.className = 'vk-key space';
        space.textContent = 'SPACE';
        space.onclick = () => { els.msgInput.value += ' '; };
        els.vkKeys.appendChild(space);
        const back = document.createElement('div');
        back.className = 'vk-key wide';
        back.innerHTML = '<i class="fa-solid fa-delete-left"></i>';
        back.onclick = () => { els.msgInput.value = els.msgInput.value.slice(0, -1); if(vkScramble) renderVk(); };
        els.vkKeys.appendChild(back);
      }

      // --- CORE LOGIC ---

      function initApp(userId, callback) {
        myId = userId;
        els.myNameDisplay.textContent = userId;
        els.myIdDisplay.textContent = "ID: " + userId;
        els.myAvatar.textContent = userId.substring(0,2).toUpperCase();
        
        peer = new Peer(myId);

        peer.on('open', (id) => {
          myId = id;
          els.myIdDisplay.textContent = "ID: " + id;
          els.loginScreen.classList.add('hidden');
          setTimeout(() => els.loginScreen.style.display = 'none', 500);
          els.app.classList.add('visible');
          if(callback) callback();
        });

        peer.on('error', (err) => {
          if(err.type === 'unavailable-id') {
            alert('ID taken. Trying random.');
            initApp(generateRandomId(), callback);
          } else {
            alert('Error: ' + err.type);
          }
        });

        peer.on('connection', (conn) => {
          handleConnection(conn, true);
        });
      }

      function connectToPeer(remoteId, presetKey) {
        if(remoteId === myId) return;
        const conn = peer.connect(remoteId);
        handleConnection(conn, false, presetKey);
      }

      function handleConnection(conn, inbound, presetKey) {
        const peerId = conn.peer;
        let chat = chats.get(peerId);
        
        if(!chat) {
          chat = {
            id: peerId,
            name: peerId,
            type: 'direct',
            passphrase: presetKey || 'changeme',
            messages: [],
            pendingMessages: [], // Store-and-forward queue
            conn: conn,
            unread: 0,
            fingerprint: null // Stored fingerprint of peer
          };
          chats.set(peerId, chat);
        } else {
          chat.conn = conn;
          if(presetKey) chat.passphrase = presetKey;
        }

        renderChatList();
        if(!activeChatId) setActiveChat(peerId);

        conn.on('open', () => {
          // Handshake: Send Name + Fingerprint
          conn.send({ 
            kind: 'handshake', 
            name: myId, 
            fingerprint: myFingerprint 
          });
          
          updateChatStatus(chat);
          renderChatList();
          
          // Resend Pending Messages (PIP)
          if(chat.pendingMessages.length > 0) {
            chat.pendingMessages.forEach(msg => {
              // Re-encrypt and send
              encryptPayload(chat.passphrase, msg.payload).then(pkg => {
                conn.send({
                  kind: 'message',
                  iv: pkg.iv,
                  data: pkg.data,
                  senderName: myId,
                  timestamp: msg.timestamp // Preserve original time
                });
              });
              msg.status = 'sent';
            });
            chat.pendingMessages = []; // Clear queue
            saveStorage();
            if(activeChatId === chat.id) renderMessages(chat);
          }
        });

        conn.on('data', (data) => handleData(conn, data));
        conn.on('close', () => { updateChatStatus(chat); renderChatList(); });
      }

      // --- GROUP CHAT LOGIC ---
      function createGroup(name) {
        const groupId = 'group-' + Date.now();
        const chat = {
          id: groupId,
          name: name,
          type: 'group',
          passphrase: 'changeme',
          messages: [],
          participants: [],
          connections: {},
          unread: 0
        };
        chats.set(groupId, chat);
        setActiveChat(groupId);
        addSystemMessage(chat, 'Group created.');
      }

      function addMemberToGroup(peerId) {
        const chat = getActiveChat();
        if(!chat || chat.type !== 'group') return;
        if(chat.participants.includes(peerId)) return;
        
        const conn = peer.connect(peerId);
        chat.participants.push(peerId);
        chat.connections[peerId] = conn;
        
        conn.on('open', () => {
          conn.send({ 
            kind: 'handshake', 
            name: myId, 
            fingerprint: myFingerprint,
            groupId: chat.id, 
            groupName: chat.name 
          });
          addSystemMessage(chat, `${peerId} added.`);
        });
        conn.on('data', (data) => handleData(conn, data));
        saveStorage();
      }

      function handleData(conn, data) {
        let chat = null;
        
        // Router
        if(data.groupId) {
          chat = chats.get(data.groupId);
          if(!chat) {
            chat = {
              id: data.groupId,
              name: data.groupName || 'Unknown Group',
              type: 'group',
              passphrase: 'changeme',
              messages: [],
              participants: [conn.peer],
              connections: { [conn.peer]: conn },
              unread: 0
            };
            chats.set(data.groupId, chat);
            renderChatList();
          } else {
            if(!chat.connections[conn.peer]) chat.connections[conn.peer] = conn;
            if(!chat.participants.includes(conn.peer)) chat.participants.push(conn.peer);
          }
        } else {
          chat = chats.get(conn.peer);
        }

        if(!chat) return;

        // Handshake & Security Check
        if(data.kind === 'handshake') {
          if(chat.type === 'direct') {
            chat.name = data.name;
            
            // Fingerprint Verification
            if(settings.secureSession) {
              if(chat.fingerprint && chat.fingerprint !== data.fingerprint) {
                addSystemMessage(chat, `锔 SECURITY ALERT: Fingerprint mismatch! Possible spoofing.`);
                logSecurity(`ALERT: ${chat.name} fingerprint changed from ${chat.fingerprint} to ${data.fingerprint}`);
                // Optionally close connection here
              } else {
                chat.fingerprint = data.fingerprint;
                logSecurity(`Verified ${chat.name}: ${data.fingerprint.substring(0,16)}...`);
              }
            } else {
              chat.fingerprint = data.fingerprint;
              logSecurity(`Connected ${chat.name}: ${data.fingerprint.substring(0,16)}...`);
            }
          }
          renderChatList();
          if(activeChatId === chat.id) els.chatTitle.textContent = chat.name;
        } 
        else if (data.kind === 'system' && data.type === 'key_change') {
          const newKey = prompt(`Key change in ${chat.name}. Enter new key:`);
          if(newKey) chat.passphrase = newKey;
          saveStorage();
        }
        else if (data.kind === 'message') {
          decryptMessage(chat.passphrase, data).then(payload => {
            if(!payload) return;
            const msgObj = {
              from: 'them',
              senderName: data.senderName || conn.peer,
              type: payload.type,
              content: payload.content,
              fileName: payload.fileName,
              timestamp: data.timestamp || new Date().toISOString(), // Use sender timestamp
              ghost: payload.ghost,
              status: 'received'
            };
            chat.messages.push(msgObj);
            if(activeChatId === chat.id) {
              appendMessageToUI(msgObj);
            } else {
              chat.unread++;
              renderChatList();
            }
            saveStorage();
          });
        }
      }

      function sendMessage() {
        const text = els.msgInput.value.trim();
        if(!text) return;
        
        const chat = getActiveChat();
        if(!chat) {
          // Visual feedback if no chat selected
          els.msgForm.classList.add('shake');
          setTimeout(() => els.msgForm.classList.remove('shake'), 500);
          return;
        }

        const payload = { type: 'text', content: text, ghost: ghostMode };
        const timestamp = new Date().toISOString();
        
        // Optimistic UI update
        const msgObj = {
          from: 'me',
          type: 'text',
          content: text,
          timestamp: timestamp,
          ghost: ghostMode,
          status: 'pending'
        };
        chat.messages.push(msgObj);
        appendMessageToUI(msgObj);
        els.msgInput.value = '';

        // Send Logic
        encryptPayload(chat.passphrase, payload).then(pkg => {
          const msgData = {
            kind: 'message',
            iv: pkg.iv,
            data: pkg.data,
            groupId: chat.type === 'group' ? chat.id : undefined,
            groupName: chat.type === 'group' ? chat.name : undefined,
            senderName: myId,
            timestamp: timestamp
          };

          if(chat.type === 'direct') {
            if(chat.conn && chat.conn.open) {
              chat.conn.send(msgData);
              msgObj.status = 'sent';
            } else {
              // Store for later (PIP)
              chat.pendingMessages.push({ payload: payload, timestamp: timestamp });
            }
          } else {
            // Group: Send to all connected
            chat.participants.forEach(pid => {
              const c = chat.connections[pid];
              if(c && c.open) c.send(msgData);
            });
            msgObj.status = 'sent';
          }
          saveStorage();
          // Update UI tick
          if(activeChatId === chat.id) renderMessages(chat);
        }).catch(err => {
          console.error("Encryption failed", err);
          msgObj.status = 'failed';
          if(activeChatId === chat.id) renderMessages(chat);
        });
      }

      function handleFileUpload(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const base64 = ev.target.result.split(',')[1];
          const chat = getActiveChat();
          if(!chat) return;

          const payload = { type: 'file', content: base64, fileName: file.name, mime: file.type, ghost: ghostMode };
          const timestamp = new Date().toISOString();

          const msgObj = {
            from: 'me',
            type: 'file',
            content: ev.target.result,
            fileName: file.name,
            timestamp: timestamp,
            ghost: ghostMode,
            status: 'pending'
          };
          chat.messages.push(msgObj);
          appendMessageToUI(msgObj);

          encryptPayload(chat.passphrase, payload).then(pkg => {
             const msgData = {
              kind: 'message',
              iv: pkg.iv,
              data: pkg.data,
              groupId: chat.type === 'group' ? chat.id : undefined,
              groupName: chat.type === 'group' ? chat.name : undefined,
              senderName: myId,
              timestamp: timestamp
            };
            
            if(chat.type === 'direct') {
              if(chat.conn && chat.conn.open) {
                chat.conn.send(msgData);
                msgObj.status = 'sent';
              } else {
                chat.pendingMessages.push({ payload: payload, timestamp: timestamp });
              }
            } else {
              chat.participants.forEach(pid => {
                const c = chat.connections[pid];
                if(c && c.open) c.send(msgData);
              });
              msgObj.status = 'sent';
            }
            saveStorage();
            if(activeChatId === chat.id) renderMessages(chat);
          });
        };
        reader.readAsDataURL(file);
        e.target.value = '';
      }

      // --- CRYPTO ---
      async function encryptPayload(pass, payload) {
        const key = await getKey(pass);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const enc = new TextEncoder();
        const data = enc.encode(JSON.stringify(payload));
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, data);
        return { iv: buf2hex(iv), data: buf2hex(ciphertext) };
      }

      async function decryptMessage(passphrase, pkg) {
        try {
          const key = await getKey(passphrase);
          const iv = hex2buf(pkg.iv);
          const data = hex2buf(pkg.data);
          const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, data);
          const dec = new TextDecoder();
          return JSON.parse(dec.decode(decrypted));
        } catch(e) { return { type: 'text', content: ' Decryption failed.' }; }
      }

      async function getKey(pass) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pass), { name: "PBKDF2" }, false, ["deriveKey"]);
        return crypto.subtle.deriveKey(
          { name: "PBKDF2", salt: enc.encode("pepechat_salt"), iterations: 1000, hash: "SHA-256" },
          keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
        );
      }

      // --- UI RENDERING ---
      function renderChatList() {
        els.chatList.innerHTML = '';
        chats.forEach(chat => {
          const div = document.createElement('div');
          div.className = `chat-item ${activeChatId === chat.id ? 'active' : ''}`;
          const isOnline = chat.type === 'group' ? true : (chat.conn && chat.conn.open);
          
          div.innerHTML = `
            <div class="avatar">${chat.name.substring(0,2).toUpperCase()}</div>
            <div style="flex:1; overflow:hidden;">
              <div style="display:flex; justify-content:space-between;">
                <span style="font-weight:600; font-size:14px;">${chat.name}</span>
                ${chat.unread > 0 ? `<span style="background:var(--danger); color:white; border-radius:10px; padding:0 6px; font-size:10px;">${chat.unread}</span>` : ''}
              </div>
              <div style="font-size:12px; color:var(--text-muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${chat.type === 'group' ? 'Group' : (isOnline ? 'Online' : 'Offline')}
              </div>
            </div>
            <div class="status-dot ${isOnline ? 'online' : ''}"></div>
          `;
          div.onclick = () => setActiveChat(chat.id);
          els.chatList.appendChild(div);
        });
      }

      function setActiveChat(id) {
        activeChatId = id;
        const chat = chats.get(id);
        if(!chat) {
          els.chatTitle.textContent = "No Chat Selected";
          els.messages.innerHTML = '';
          return;
        }
        chat.unread = 0;
        els.chatTitle.textContent = chat.name;
        
        if(chat.type === 'group') {
          els.chatStatus.innerHTML = `<span style="color:var(--accent); cursor:pointer;" onclick="openModal(document.getElementById('groupAddMemberModal'))">+ Add Member</span>`;
        } else {
          updateChatStatus(chat);
        }
        
        renderMessages(chat);
        renderChatList();
        if(window.innerWidth <= 768) els.sidebar.classList.remove('open');
      }

      function updateChatStatus(chat) {
        if(activeChatId !== chat.id || chat.type === 'group') return;
        const isOnline = chat.conn && chat.conn.open;
        els.chatStatus.textContent = isOnline ? "Online 路 Encrypted" : "Offline (Messages queued)";
        els.chatStatus.style.color = isOnline ? "var(--success)" : "var(--warning)";
      }

      function renderMessages(chat) {
        els.messages.innerHTML = '';
        chat.messages.forEach(appendMessageToUI);
      }

      function appendMessageToUI(msg) {
        const div = document.createElement('div');
        div.className = `msg ${msg.from === 'me' ? 'out' : 'in'} ${msg.ghost ? 'ghost-fade' : ''}`;
        
        let contentHtml = '';
        
        // ZERO TRUST RENDERING
        if(msg.type === 'text') {
          contentHtml = sanitize(msg.content);
        } else if (msg.type === 'file') {
          // Do not render image tag. Render a button.
          const btnId = 'reveal-' + Math.random().toString(36).substr(2, 9);
          const isImg = msg.mime && msg.mime.startsWith('image/');
          
          contentHtml = `
            <div class="reveal-btn" onclick="revealContent('${btnId}', '${msg.type}', '${msg.content}', '${msg.fileName}')" id="${btnId}">
              <i class="fa-solid ${isImg ? 'fa-image' : 'fa-file'}"></i>
              ${isImg ? 'Click to Load Image' : 'Click to Download File'}
            </div>
          `;
        }

        const senderInfo = (msg.from === 'them' && msg.senderName) ? `<div style="font-size:10px; color:var(--accent); margin-bottom:2px;">${sanitize(msg.senderName)}</div>` : '';
        
        // Status Tick
        let statusIcon = '';
        if(msg.from === 'me') {
          if(msg.status === 'pending') statusIcon = '<i class="fa-regular fa-clock"></i>';
          else if(msg.status === 'sent') statusIcon = '<i class="fa-solid fa-check"></i>';
          else if(msg.status === 'failed') statusIcon = '<i class="fa-solid fa-circle-exclamation" style="color:red"></i>';
        }

        div.innerHTML = `
          ${senderInfo}
          ${contentHtml}
          <div class="msg-meta">
            ${msg.ghost ? ' ' : ''}
            <span class="msg-status">${statusIcon}</span>
            ${new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
          </div>
        `;
        
        els.messages.appendChild(div);
        els.messages.scrollTop = els.messages.scrollHeight;

        if(msg.ghost) {
          setTimeout(() => { if(div.parentNode) div.parentNode.removeChild(div); }, 30000);
        }
      }

      // Zero Trust Reveal Function (Global scope for onclick)
      window.revealContent = (elemId, type, content, fileName) => {
        const el = document.getElementById(elemId);
        if(!el) return;
        
        if(type === 'file') {
          // Check mime again
          // If image, replace with img tag
          if(content.startsWith('data:image')) {
             const img = document.createElement('img');
             img.src = content;
             el.parentNode.replaceChild(img, el);
          } else {
             // Trigger download
             const a = document.createElement('a');
             a.href = content;
             a.download = fileName;
             a.click();
             el.innerHTML = `<i class="fa-solid fa-check"></i> Downloaded`;
          }
        }
      };

      function addSystemMessage(chat, text) {
        if(!chat) return;
        const msg = { from: 'system', type: 'text', content: text, timestamp: new Date().toISOString() };
        chat.messages.push(msg);
        if(activeChatId === chat.id) appendMessageToUI(msg);
      }

      // --- HELPERS ---
      function sanitize(str) {
        const temp = document.createElement('div');
        temp.textContent = str;
        return temp.innerHTML;
      }
      
      window.openModal = (el) => { el.classList.add('open'); el.querySelector('.modal').style.transform = 'scale(1)'; };
      window.closeModals = () => { document.querySelectorAll('.modal-overlay').forEach(el => el.classList.remove('open')); };
      
      function showQrModal() {
        if(!myId) return;
        const chat = getActiveChat();
        const key = chat ? chat.passphrase : 'changeme';
        const url = `${APP_URL}?connect=${myId}&key=${btoa(key)}`;
        
        // FIX: Ensure modal is open before drawing QR code so canvas has dimensions
        openModal(els.qrModal);
        
        setTimeout(() => {
          els.qrCanvas.innerHTML = '';
          new QRCode(els.qrCanvas, { text: url, width: 200, height: 200 });
          els.shareUrlInput.value = url;
        }, 50);
      }
      
      function generateRandomId() { return 'user-' + Math.floor(Math.random() * 100000); }
      function buf2hex(buffer) { return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join(''); }
      function hex2buf(hex) { return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))); }
      
      function saveStorage() {
        const chatsArr = Array.from(chats.entries()).map(([k, v]) => {
          const { conn, connections, ...rest } = v; 
          return [k, rest];
        });
        const data = { myId, chats: chatsArr, settings };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      }
      
      function loadStorage() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw) {
          try {
            const data = JSON.parse(raw);
            if(data.settings) {
              settings = data.settings;
              els.secureSessionToggle.checked = settings.secureSession;
            }
            if(data.chats) {
              chats = new Map(data.chats);
              chats.forEach(c => { 
                c.conn = null; 
                c.connections = {}; 
                c.unread = c.unread || 0; 
                c.pendingMessages = c.pendingMessages || [];
              });
            }
          } catch(e) {}
        }
      }

      function getActiveChat() {
        return activeChatId ? chats.get(activeChatId) : null;
      }

    })();
  </script>
</body>
</html>
