<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PepeChat v14.1 ¬∑ Glare Free (Fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />

  <!-- QR Code Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top left, #0f0f0f 0%, #000000 100%);
      --glass-panel: rgba(15, 15, 15, 0.95);
      --glass-border: rgba(255, 255, 255, 0.08);
      --accent: #0A84FF;
      --accent-grad: linear-gradient(135deg, #0A84FF, #0056b3);
      --text-main: #e0e0e0;
      --text-muted: #8e8e93;
      --bubble-in: #262628;
      --bubble-out: #0A84FF;
      --danger: #FF453A;
      --success: #30D158;
      --warning: #FFD60A;
      --morse-active: #FFD60A;
      --font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --safe-bottom: env(safe-area-inset-bottom, 20px);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0;
      font-family: var(--font-stack);
      background: var(--bg-gradient);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* --- LOGIN SCREEN --- */
    #loginScreen {
      position: absolute; inset: 0; z-index: 100;
      background: rgba(0,0,0,0.95); backdrop-filter: blur(20px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: opacity 0.3s ease;
    }
    #loginScreen.hidden { opacity: 0; pointer-events: none; display: none; }

    .login-card {
      background: rgba(30,30,30,0.9); padding: 40px; border-radius: 24px;
      border: 1px solid var(--glass-border); text-align: center; width: 90%; max-width: 400px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .login-input {
      width: 100%; padding: 14px; border-radius: 12px; border: 1px solid var(--glass-border);
      background: rgba(0,0,0,0.5); color: white; font-size: 16px; outline: none; margin-bottom: 15px;
    }
    .btn-primary {
      width: 100%; padding: 14px; border-radius: 12px; border: none;
      background: var(--accent-grad); color: white; font-weight: 600; font-size: 16px; cursor: pointer;
    }
    .btn-primary:disabled { opacity: 0.7; cursor: not-allowed; }

    /* --- MAIN APP LAYOUT --- */
    #app {
      position: relative;
      width: 100%; height: 100%; max-width: 1600px; display: flex;
      background: var(--glass-panel); backdrop-filter: blur(30px);
      box-shadow: 0 0 50px rgba(0,0,0,0.8); opacity: 0; transform: scale(0.98);
      transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    #app.visible { opacity: 1; transform: scale(1); }

    /* SIDEBAR OVERLAY */
    .sidebar-overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,0.5); z-index: 55;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .sidebar-overlay.visible { opacity: 1; pointer-events: auto; }

    /* SIDEBAR */
    aside {
      width: 320px; border-right: 1px solid var(--glass-border);
      display: flex; flex-direction: column; background: rgba(0,0,0,0.3);
      z-index: 60; position: relative;
    }
    .sidebar-header { padding: 20px; border-bottom: 1px solid var(--glass-border); }
    .user-profile { display: flex; align-items: center; gap: 10px; }
    .avatar {
      width: 40px; height: 40px; border-radius: 50%;
      background: linear-gradient(45deg, #444, #666);
      display: flex; align-items: center; justify-content: center; font-weight: bold;
      flex-shrink: 0;
    }
    .sidebar-actions { padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .action-btn {
      background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); padding: 10px;
      border-radius: 8px; color: var(--text-main); font-size: 12px; cursor: pointer;
      display: flex; align-items: center; justify-content: center; gap: 6px;
    }
    .action-btn:hover { background: rgba(255,255,255,0.1); }

    .chat-list { flex: 1; overflow-y: auto; padding: 10px; }
    .chat-item {
      padding: 12px; border-radius: 10px; cursor: pointer;
      display: flex; align-items: center; gap: 12px; margin-bottom: 5px;
      border: 1px solid transparent;
    }
    .chat-item:hover { background: rgba(255,255,255,0.05); }
    .chat-item.active { background: rgba(10, 132, 255, 0.15); border-color: rgba(10,132,255,0.3); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
    .status-dot.online { background: var(--success); box-shadow: 0 0 8px var(--success); }
    .status-dot.connecting { background: var(--warning); animation: pulse 1s infinite; }
    .status-dot.failed { background: var(--danger); }

    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* CHAT AREA */
    main {
      flex: 1; display: flex; flex-direction: column; position: relative;
      background: rgba(0,0,0,0.2); z-index: 50;
    }
    .chat-header {
      padding: 15px 20px; border-bottom: 1px solid var(--glass-border);
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(30,30,30,0.6); backdrop-filter: blur(10px);
    }
    .header-controls { display: flex; gap: 10px; align-items: center; }
    .icon-btn {
      background: transparent; border: none; color: var(--text-muted);
      cursor: pointer; font-size: 16px; padding: 8px; border-radius: 50%;
    }
    .icon-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.1); }
    .icon-btn.active { color: var(--accent); background: rgba(10,132,255,0.15); }
    .icon-btn.danger { color: var(--danger); }
    .icon-btn.danger:hover { background: rgba(255, 69, 58, 0.2); }

    .messages-container {
      flex: 1; overflow-y: auto; padding: 20px;
      display: flex; flex-direction: column; gap: 8px;
    }
    .msg {
      max-width: 75%; padding: 10px 14px; border-radius: 18px;
      font-size: 14px; line-height: 1.4; position: relative; word-wrap: break-word;
    }
    .msg.in { align-self: flex-start; background: var(--bubble-in); border-bottom-left-radius: 4px; }
    .msg.out { align-self: flex-end; background: var(--bubble-out); border-bottom-right-radius: 4px; color: white; }
    .msg.system { align-self: center; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); font-size: 11px; max-width: 90%; color: var(--text-muted); text-align: center; }

    /* File Card Styles */
    .file-card {
      background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px; padding: 10px; margin-top: 5px;
      display: flex; flex-direction: column; gap: 8px; min-width: 200px;
    }
    .file-header { display: flex; align-items: center; gap: 10px; font-size: 12px; font-weight: 600; }
    .file-actions { display: flex; gap: 5px; margin-top: 5px; }
    .file-btn-small {
      flex: 1; background: rgba(255,255,255,0.1); border: none; color: white;
      padding: 6px; border-radius: 6px; cursor: pointer; font-size: 11px;
      display: flex; align-items: center; justify-content: center; gap: 5px;
    }
    .file-btn-small:hover { background: rgba(255,255,255,0.2); }
    .file-info-icon { color: var(--accent); cursor: pointer; margin-left: auto; padding: 0 5px; }

    /* Audio Visualizer */
    .audio-visualizer {
      display: flex; align-items: center; gap: 10px; min-width: 200px; height: 40px;
      background: rgba(0,0,0,0.2); border-radius: 20px; padding: 0 10px;
    }
    .play-icon { cursor: pointer; font-size: 14px; width: 20px; text-align: center; }
    .waveform-canvas { flex: 1; height: 100%; }

    /* Progress Bar */
    .progress-track {
      width: 100%; height: 4px; background: rgba(255,255,255,0.1);
      border-radius: 2px; overflow: hidden; margin-top: 5px;
    }
    .progress-fill {
      height: 100%; background: var(--success); width: 0%;
      transition: width 0.2s ease;
    }

    .msg img { max-width: 100%; border-radius: 10px; margin-top: 5px; display: block; }

    .msg-meta { font-size: 10px; opacity: 0.7; margin-top: 4px; display: flex; justify-content: flex-end; gap: 6px; align-items: center; }
    .msg-status { font-size: 10px; }
    .copy-btn { cursor: pointer; margin-right: 5px; opacity: 0.5; }
    .copy-btn:hover { opacity: 1; color: var(--accent); }

    .ghost-fade { animation: fadeOut 30s forwards; }
    @keyframes fadeOut { 0% { opacity: 1; } 90% { opacity: 0.1; filter: blur(2px); } 100% { opacity: 0; display: none; } }

    /* INPUT AREA - Mobile Optimized */
    .input-area {
      padding: 10px;
      padding-bottom: calc(10px + var(--safe-bottom));
      border-top: 1px solid var(--glass-border);
      display: flex; gap: 6px; align-items: center; background: rgba(30,30,30,0.6);
      transition: padding-bottom 0.3s;
      flex-wrap: nowrap;
    }
    .msg-input {
      flex: 1; background: rgba(0,0,0,0.4); border: 1px solid var(--glass-border);
      border-radius: 20px; padding: 10px 12px; color: white; outline: none; font-size: 14px;
      min-width: 50px;
    }
    .msg-input:focus { border-color: var(--accent); }
    .file-btn {
      color: var(--accent); background: rgba(10,132,255,0.1); border: none;
      width: 36px; height: 36px; border-radius: 50%; cursor: pointer;
      display: flex; align-items: center; justify-content: center; flex-shrink: 0;
      font-size: 14px;
    }
    .file-btn:hover { background: rgba(10,132,255,0.2); }
    .file-btn.recording { background: var(--danger); color: white; animation: pulse-red 1s infinite; }
    @keyframes pulse-red { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

    /* SECURITY LOG */
    #securityLog {
      height: 0; overflow: hidden; background: #000; border-top: 1px solid var(--glass-border);
      font-family: monospace; font-size: 10px; color: var(--success);
      transition: height 0.3s; display: flex; flex-direction: column;
      position: absolute; bottom: 60px; left: 0; right: 0; z-index: 9999;
    }
    #securityLog.open { height: 60%; border-top: 2px solid var(--accent); }
    .log-header {
      padding: 8px 15px; background: #111; cursor: pointer; display: flex; justify-content: space-between;
    }
    .log-tabs { display: flex; gap: 15px; }
    .log-tab { opacity: 0.5; cursor: pointer; }
    .log-tab.active { opacity: 1; text-decoration: underline; color: var(--accent); }
    .log-content { padding: 10px; overflow-y: auto; flex: 1; }
    .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; display: flex; gap: 10px; }
    .log-row.error { color: var(--danger); }
    .log-row.warn { color: var(--warning); }
    .log-hash { color: #888; user-select: all; }
    .log-btn { background: #333; border: 1px solid #555; color: white; font-size: 9px; padding: 2px 6px; cursor: pointer; border-radius: 4px; }

    /* VIRTUAL KEYBOARD */
    #virtualKeyboard {
      height: 0; overflow: hidden; transition: height 0.3s ease;
      background: #151515; border-top: 1px solid var(--glass-border);
      display: flex; flex-direction: column;
      padding-bottom: 20px;
    }
    #virtualKeyboard.open { height: 320px; }
    .vk-toolbar { display: flex; justify-content: space-between; padding: 5px 10px; background: #222; font-size: 12px; }
    .vk-tabs { display:flex; gap:10px; }
    .vk-tab { opacity: .6; cursor: pointer; padding: 4px 8px; border-radius: 6px; }
    .vk-tab.active { opacity: 1; background: rgba(255,255,255,0.08); color: var(--accent); }
    .vk-keys { flex: 1; padding: 10px; display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; overflow-y: auto; align-content: start; }
    .vk-key {
      background: #333; color: white; border-radius: 5px; height: 40px;
      display: flex; align-items: center; justify-content: center; cursor: pointer;
      font-size: 16px; user-select: none; box-shadow: 0 2px 0 #000;
    }
    .vk-key:active { transform: translateY(2px); box-shadow: none; }
    .vk-key.space { grid-column: span 6; }
    .vk-key.wide { grid-column: span 2; }
    .vk-key.arrow { background: #444; }

    /* MODALS */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
      z-index: 200; display: flex; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal {
      background: #1c1c1e; border: 1px solid var(--glass-border); border-radius: 20px;
      padding: 25px; width: 90%; max-width: 350px; text-align: center; transform: scale(0.9);
      max-height: 90vh; overflow-y: auto;
    }
    .modal-overlay.open .modal { transform: scale(1); }
    .modal-actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    .btn-sec { background: rgba(255,255,255,0.1); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; }

    /* Toggle Switch */
    .toggle-row { display: flex; justify-content: space-between; align-items: center; margin: 15px 0; font-size: 14px; }
    .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 34px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent); }
    input:checked + .slider:before { transform: translateX(16px); }

    /* Drawing Canvas */
    .canvas-container {
      position: relative; width: 100%; height: 350px; background: #fff;
      border-radius: 8px; overflow: hidden; touch-action: none;
      cursor: crosshair;
    }
    #drawingCanvas { width: 100%; height: 100%; display: block; }
    .color-picker { display: flex; gap: 5px; justify-content: center; margin: 10px 0; }
    .color-dot { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
    .color-dot.active { border-color: white; transform: scale(1.2); }
    .peer-cursor {
      position: absolute; pointer-events: none; font-size: 10px; color: white;
      background: var(--accent); padding: 2px 6px; border-radius: 4px;
      transform: translate(-50%, -100%); white-space: nowrap;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: top 0.1s, left 0.1s;
    }

    /* Recording Overlay */
    #recordingOverlay {
      position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
      background: var(--danger); padding: 10px 20px; border-radius: 30px;
      color: white; font-weight: bold; display: none; align-items: center; gap: 10px;
      box-shadow: 0 5px 20px rgba(255, 69, 58, 0.4); z-index: 50;
    }
    #recordingOverlay.visible { display: flex; animation: bounceIn 0.3s; }
    @keyframes bounceIn { 0% { transform: translate(-50%, 20px); opacity: 0; } 100% { transform: translate(-50%, 0); opacity: 1; } }

    /* MORSE MODE */
    .morse-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 300;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .morse-overlay.visible { opacity: 1; pointer-events: auto; }
    .morse-btn-main {
      width: 200px; height: 200px; border-radius: 50%;
      background: #333; border: 5px solid #555;
      color: #888; font-size: 24px; font-weight: bold;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; user-select: none; touch-action: manipulation;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      transition: all 0.1s;
    }
    .morse-btn-main:active, .morse-btn-main.active {
      background: var(--morse-active); color: black;
      transform: scale(0.95); box-shadow: 0 0 50px var(--morse-active);
      border-color: white;
    }
    .morse-status { margin-top: 30px; font-family: monospace; color: var(--accent); height: 20px; }
    .morse-close { position: absolute; top: 20px; right: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; }

    @media (max-width: 768px) {
      aside { position: absolute; height: 100%; transform: translateX(-100%); transition: transform 0.3s; background: #111; width: 85%; }
      aside.open { transform: translateX(0); }
      .mobile-menu-btn { display: block; }
    }
    @media (min-width: 769px) { .mobile-menu-btn { display: none; } }
    .hidden-file { display: none; }

    /* Raw Data Box */
    .raw-data-box {
      background: #111; border: 1px solid #333; padding: 10px; margin-top: 10px;
      font-family: monospace; font-size: 10px; color: #aaa; text-align: left;
      max-height: 200px; overflow-y: auto; white-space: pre-wrap; word-break: break-all;
    }

    /* File Info Table */
    .file-info-table { width: 100%; text-align: left; font-size: 12px; margin-top: 10px; border-collapse: collapse; }
    .file-info-table td { padding: 5px; border-bottom: 1px solid #333; }
    .file-info-table td:first-child { color: #888; width: 80px; }
    .file-info-table td:last-child { color: #fff; word-break: break-all; font-family: monospace; }
  </style>
</head>
<body>

  <!-- LOGIN SCREEN -->
  <div id="loginScreen">
    <div class="login-card">
      <div style="font-size: 40px; margin-bottom: 10px;">üê∏</div>
      <h1>PepeChat v14.1</h1>
      <p>Ephemeral ¬∑ Collaborative ¬∑ Resilient</p>
      <form id="loginForm">
        <input type="text" id="customIdInput" class="login-input" placeholder="Username (Empty for Random)" autocomplete="off" maxlength="20">
        <button type="submit" id="loginBtn" class="btn-primary">Start Chatting</button>
        <div style="margin-top: 15px; font-size: 12px; color: #666;">
          Tor & Mobile Optimized
        </div>
      </form>
    </div>
  </div>

  <!-- MORSE OVERLAY -->
  <div class="morse-overlay" id="morseOverlay">
    <button class="morse-close" id="closeMorseBtn"><i class="fa-solid fa-xmark"></i></button>
    <h2 style="margin-bottom: 40px;">Morse Telegraph</h2>
    <div class="morse-btn-main" id="morseTapBtn">TAP</div>
    <div class="morse-status" id="morseStatus">Ready...</div>
    <p style="margin-top: 20px; font-size: 12px; color: #666;">Hold to beep. Auto-sends after 3s silence.</p>
  </div>

  <!-- MAIN APP -->
  <div id="app">
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <aside id="sidebar">
      <div class="sidebar-header">
        <div class="user-profile">
          <div class="avatar" id="myAvatar">?</div>
          <div class="user-info">
            <h3 id="myNameDisplay">Guest</h3>
            <span id="myIdDisplay" style="font-size:10px; color:#666;">...</span>
            <i class="fa-regular fa-copy" id="copyMyIdBtn" style="cursor:pointer; font-size:12px; margin-left:5px; color:var(--accent);" title="Copy ID"></i>
          </div>
        </div>
      </div>

      <div class="sidebar-actions">
        <button class="action-btn" id="showQrBtn"><i class="fa-solid fa-qrcode"></i> QR</button>
        <button class="action-btn" id="addPeerBtn"><i class="fa-solid fa-user-plus"></i> Chat</button>
        <button class="action-btn" id="createGroupBtn"><i class="fa-solid fa-users"></i> Group</button>
        <button class="action-btn" id="settingsBtn"><i class="fa-solid fa-shield-halved"></i> Security</button>
      </div>

      <div class="chat-list" id="chatList"></div>
    </aside>

    <main>
      <div class="chat-header">
        <button class="icon-btn mobile-menu-btn" id="menuBtn"><i class="fa-solid fa-bars"></i></button>
        <div class="chat-meta">
          <h2 id="chatTitle">No Chat Selected</h2>
          <p id="chatStatus">Waiting...</p>
        </div>
        <div class="header-controls">
          <button class="icon-btn" id="reconnectBtn" title="Force Reconnect" style="display:none; color:var(--warning);"><i class="fa-solid fa-rotate"></i></button>
          <button class="icon-btn" id="ghostToggle" title="Ghost Mode"><i class="fa-solid fa-ghost"></i></button>
          <button class="icon-btn" id="keySettingsBtn" title="Encryption"><i class="fa-solid fa-key"></i></button>
          <button class="icon-btn" id="debugToggleBtn" title="Show Logs"><i class="fa-solid fa-bug"></i></button>
          <button class="icon-btn danger" id="deleteChatBtn" title="Nuke Chat (Remote Wipe)"><i class="fa-solid fa-radiation"></i></button>
        </div>
      </div>

      <div class="messages-container" id="messages">
        <div class="msg system">Select a chat or create a group to begin.</div>
      </div>

      <div id="recordingOverlay">
        <i class="fa-solid fa-microphone-lines fa-beat"></i> Recording... <span id="recTimer">0:00</span>
      </div>

      <form class="input-area" id="msgForm">
        <button type="button" class="file-btn" id="uploadBtn"><i class="fa-solid fa-paperclip"></i></button>
        <button type="button" class="file-btn" id="drawBtn" title="Collaborative Drawing"><i class="fa-solid fa-paintbrush"></i></button>
        <button type="button" class="file-btn" id="morseBtn" title="Morse Code Mode"><i class="fa-solid fa-teletype"></i></button>
        <button type="button" class="file-btn" id="micBtn" title="Hold to Record"><i class="fa-solid fa-microphone"></i></button>
        <input type="file" id="fileInput" class="hidden-file">
        <input type="text" class="msg-input" id="msgInput" placeholder="Type message..." autocomplete="off">
        <button type="button" class="file-btn" id="vkToggleBtn" title="Virtual Keyboard"><i class="fa-solid fa-keyboard"></i></button>
        <button type="submit" class="file-btn" id="sendBtn" style="background: var(--accent); color: white;"><i class="fa-solid fa-paper-plane"></i></button>
      </form>

      <!-- SECURITY LOG -->
      <div id="securityLog">
        <div class="log-header" id="logHeader">
          <div class="log-tabs">
            <span class="log-tab" id="tabSec">Security Log</span>
            <span class="log-tab active" id="tabDebug">Debug Log</span>
          </div>
          <div style="display:flex; gap:10px;">
            <button class="log-btn" id="viewRawDataBtn">View Raw Data</button>
            <i class="fa-solid fa-chevron-up"></i>
          </div>
        </div>
        <div class="log-content" id="logContent">
          <div class="log-row">System: Zero Trust Rendering Active.</div>
        </div>
      </div>

      <!-- VIRTUAL KEYBOARD -->
      <div id="virtualKeyboard">
        <div class="vk-toolbar">
          <div class="vk-tabs">
            <div class="vk-tab active" data-set="abc">ABC</div>
            <div class="vk-tab" data-set="123">123</div>
            <div class="vk-tab" data-set="sym">#+=</div>
            <div class="vk-tab" data-set="emo">üòä</div>
          </div>
          <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#888;">
            <input type="checkbox" id="scrambleToggle"> Scramble
          </label>
        </div>
        <div class="vk-keys" id="vkKeys"></div>
      </div>
    </main>
  </div>

  <!-- MODALS -->
  <div class="modal-overlay" id="qrModal">
    <div class="modal">
      <h3>Scan to Connect</h3>
      <div class="qr-container" id="qrCanvas" style="background:white; padding:10px; margin:10px auto; width:fit-content; min-height:200px; min-width:200px;"></div>
      <input type="text" id="shareUrlInput" readonly style="width:100%; background:#333; border:none; color:#888; font-size:10px; padding:5px; margin-bottom:10px;">
      <div class="modal-actions">
        <button class="btn-sec" id="copyLinkBtn">Copy Link</button>
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="addPeerModal">
    <div class="modal">
      <h3>Connect to Peer</h3>
      <input type="text" id="remoteIdInput" class="login-input" placeholder="Enter Peer ID">
      <div class="modal-actions">
        <button class="btn-primary" id="connectSubmitBtn">Connect</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="createGroupModal">
    <div class="modal">
      <h3>Create Group Chat</h3>
      <input type="text" id="groupNameInput" class="login-input" placeholder="Group Name">
      <div class="modal-actions">
        <button class="btn-primary" id="createGroupSubmitBtn">Create</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="groupAddMemberModal">
    <div class="modal">
      <h3>Add Member to Group</h3>
      <input type="text" id="groupMemberIdInput" class="login-input" placeholder="Peer ID to Add">
      <div class="modal-actions">
        <button class="btn-primary" id="groupAddMemberSubmitBtn">Add</button>
        <button class="btn-sec" onclick="closeModals()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <h3>Security & Connectivity</h3>

      <div class="toggle-row">
        <span>Secure Session (Fingerprint Lock)</span>
        <label class="switch">
          <input type="checkbox" id="secureSessionToggle">
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-row">
        <span>Allow Incoming Files</span>
        <label class="switch">
          <input type="checkbox" id="allowFilesToggle" checked>
          <span class="slider"></span>
        </label>
      </div>

      <hr style="border:0; border-top:1px solid #333; margin:15px 0;">

      <h4>Connectivity (Fix NAT / Mobile)</h4>

      <div class="toggle-row">
        <span>Use OpenRelay TURN (Free)</span>
        <label class="switch">
          <input type="checkbox" id="useOpenRelayToggle" checked>
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-row">
        <span>Force Relay Only (TURN)</span>
        <label class="switch">
          <input type="checkbox" id="forceRelayToggle">
          <span class="slider"></span>
        </label>
      </div>

      <p style="font-size:11px; color:#888; margin: 10px 0 0;">
        If ICE fails (NAT/CGNAT), TURN is required. OpenRelay is enabled by default for maximum compatibility.
      </p>

      <hr style="border:0; border-top:1px solid #333; margin:15px 0;">

      <h4>Custom TURN Server (Optional)</h4>
      <input type="text" id="turnUrlInput" class="login-input" placeholder="turn:your-server.com:3478" style="font-size:12px; padding:8px;">
      <input type="text" id="turnUserInput" class="login-input" placeholder="Username" style="font-size:12px; padding:8px;">
      <input type="password" id="turnPassInput" class="login-input" placeholder="Password" style="font-size:12px; padding:8px;">
      <button class="btn-primary" id="saveTurnBtn" style="padding:8px; font-size:12px;">Save & Apply</button>

      <div class="modal-actions">
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="keyModal">
    <div class="modal">
      <h3 id="keyModalTitle">Encryption Key</h3>
      <input type="text" id="keyInput" class="login-input" placeholder="Secret Passphrase">
      <p style="font-size:11px; color:#888; margin-top:-6px;">
        Tip: If no chat selected, this sets the default key used for new chats and QR invites.
      </p>
      <div class="modal-actions">
        <button class="btn-primary" id="saveKeyBtn">Update</button>
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="rawDataModal">
    <div class="modal" style="max-width:500px;">
      <h3>Fingerprint Raw Data</h3>
      <p style="font-size:11px; color:#888;">This data is hashed to create your unique session ID.</p>
      <div class="raw-data-box" id="rawDataContent"></div>
      <div class="modal-actions">
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <!-- FILE INFO MODAL -->
  <div class="modal-overlay" id="fileInfoModal">
    <div class="modal">
      <h3>File Metadata</h3>
      <table class="file-info-table">
        <tr><td>Name</td><td id="fiName"></td></tr>
        <tr><td>Type</td><td id="fiType"></td></tr>
        <tr><td>Size</td><td id="fiSize"></td></tr>
        <tr><td>Hash (SHA256)</td><td id="fiHash"></td></tr>
      </table>
      <div class="modal-actions">
        <button class="btn-sec" onclick="closeModals()">Close</button>
      </div>
    </div>
  </div>

  <!-- DRAWING MODAL -->
  <div class="modal-overlay" id="drawingModal">
    <div class="modal" style="max-width: 600px; width: 95%;">
      <h3>Collaborative Canvas</h3>
      <div class="color-picker" id="colorPicker">
        <div class="color-dot active" style="background: #000;" data-color="#000000"></div>
        <div class="color-dot" style="background: #FF453A;" data-color="#FF453A"></div>
        <div class="color-dot" style="background: #30D158;" data-color="#30D158"></div>
        <div class="color-dot" style="background: #0A84FF;" data-color="#0A84FF"></div>
        <div class="color-dot" style="background: #FFD60A;" data-color="#FFD60A"></div>
      </div>
      <div class="canvas-container" id="canvasContainer">
        <canvas id="drawingCanvas"></canvas>
      </div>
      <div class="modal-actions">
        <button class="btn-primary" id="finishDrawingBtn">Save & Send</button>
        <button class="btn-sec" id="cancelDrawingBtn">Close</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // --- CONFIG & STATE ---
      const APP_URL = `${window.location.origin}${window.location.pathname}`;
      const STORAGE_KEY = 'pepechat_v141_data';
      const CHUNK_SIZE = 16384;

      // Default ICE Servers (STUN)
      const DEFAULT_ICE = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' }
      ];

      // OpenRelay TURN (Static Auth via shared secret) - enabled by default.
      // If you prefer, disable it in Settings and use your own TURN server.
      const OPENRELAY = {
        host: 'staticauth.openrelay.metered.ca',
        secret: 'openrelayprojectsecret',
        ttlSeconds: 3600
      };

      let peer = null;
      let myId = null;
      let myFingerprint = null;
      let myFingerprintRaw = [];
      let chats = new Map();
      let activeChatId = null;
      let ghostMode = false;
      let heartbeatInterval = null;
      let activeLogTab = 'debug';

      let settings = {
        secureSession: false,
        allowFiles: true,

        // Connectivity
        useOpenRelay: true,
        forceRelay: false,

        // Custom TURN (optional)
        turnUrl: '',
        turnUser: '',
        turnPass: '',

        // Default key for new chats + QR invites
        defaultPassphrase: 'changeme'
      };

      // Connection Registry for Glare Handling
      const connRegistry = new Map(); // peerId => { conn, dir: 'in'|'out', createdAt }

      // Pending Auto-Connect
      let pendingConnect = null;

      // File Transfer State
      let incomingFiles = {};

      // Virtual Keyboard State
      let vkActive = false;
      let vkSet = 'abc';
      let vkScramble = false;

      // Drawing State
      let isDrawing = false;
      let drawCtx = null;
      let drawColor = '#000000';
      let drawingActive = false;
      let lastX = 0;
      let lastY = 0;
      let drawingInitialized = false;
      let lastCursorSentAt = 0;

      // Audio Recording State
      let mediaRecorder = null;
      let audioChunks = [];
      let isRecording = false;
      let recStartTime = 0;
      let recTimerInterval = null;
      let audioContext = null;

      // Morse Code State
      let morseActive = false;
      let morseOscillator = null;
      let morseGain = null;
      let morseStartTime = 0;
      let morseSequence = [];
      let morseTimeout = null;

      // --- INDEXED DB WRAPPER ---
      const DB_NAME = 'PepeChatDB';
      const DB_VERSION = 1;
      let db = null;

      function initDB() {
        return new Promise((resolve, reject) => {
          try {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
              db = e.target.result;
              if (!db.objectStoreNames.contains('messages')) {
                db.createObjectStore('messages', { keyPath: 'id' });
              }
            };
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onerror = (e) => reject(e);
          } catch(e) { reject(e); }
        });
      }

      function saveMessageToDB(msg) {
        if (!db || !msg || !msg.id) return;
        try {
          const tx = db.transaction(['messages'], 'readwrite');
          tx.objectStore('messages').put(msg);
        } catch(e) { console.error("DB Save Error", e); }
      }

      function loadMessagesFromDB(chatId) {
        return new Promise((resolve) => {
          if (!db) return resolve([]);
          try {
            const tx = db.transaction(['messages'], 'readonly');
            const store = tx.objectStore('messages');
            const request = store.getAll();
            request.onsuccess = () => {
              const all = request.result || [];
              const chatMsgs = all.filter(m => m.chatId === chatId).sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
              resolve(chatMsgs);
            };
            request.onerror = () => resolve([]);
          } catch(e) { resolve([]); }
        });
      }

      // --- DOM ELEMENTS ---
      const els = {
        loginScreen: document.getElementById('loginScreen'),
        loginForm: document.getElementById('loginForm'),
        customIdInput: document.getElementById('customIdInput'),
        loginBtn: document.getElementById('loginBtn'),
        app: document.getElementById('app'),
        sidebar: document.getElementById('sidebar'),
        sidebarOverlay: document.getElementById('sidebarOverlay'),
        menuBtn: document.getElementById('menuBtn'),

        myAvatar: document.getElementById('myAvatar'),
        myNameDisplay: document.getElementById('myNameDisplay'),
        myIdDisplay: document.getElementById('myIdDisplay'),
        copyMyIdBtn: document.getElementById('copyMyIdBtn'),
        chatList: document.getElementById('chatList'),

        showQrBtn: document.getElementById('showQrBtn'),
        addPeerBtn: document.getElementById('addPeerBtn'),
        createGroupBtn: document.getElementById('createGroupBtn'),
        settingsBtn: document.getElementById('settingsBtn'),

        chatTitle: document.getElementById('chatTitle'),
        chatStatus: document.getElementById('chatStatus'),
        messages: document.getElementById('messages'),
        msgForm: document.getElementById('msgForm'),
        msgInput: document.getElementById('msgInput'),
        fileInput: document.getElementById('fileInput'),
        uploadBtn: document.getElementById('uploadBtn'),
        drawBtn: document.getElementById('drawBtn'),
        micBtn: document.getElementById('micBtn'),
        morseBtn: document.getElementById('morseBtn'),
        recordingOverlay: document.getElementById('recordingOverlay'),
        recTimer: document.getElementById('recTimer'),
        vkToggleBtn: document.getElementById('vkToggleBtn'),
        sendBtn: document.getElementById('sendBtn'),
        ghostToggle: document.getElementById('ghostToggle'),
        keySettingsBtn: document.getElementById('keySettingsBtn'),
        deleteChatBtn: document.getElementById('deleteChatBtn'),
        debugToggleBtn: document.getElementById('debugToggleBtn'),
        reconnectBtn: document.getElementById('reconnectBtn'),

        // Logs
        securityLog: document.getElementById('securityLog'),
        logHeader: document.getElementById('logHeader'),
        logContent: document.getElementById('logContent'),
        viewRawDataBtn: document.getElementById('viewRawDataBtn'),
        tabSec: document.getElementById('tabSec'),
        tabDebug: document.getElementById('tabDebug'),

        // VK
        virtualKeyboard: document.getElementById('virtualKeyboard'),
        vkKeys: document.getElementById('vkKeys'),
        vkTabs: document.querySelectorAll('.vk-tab'),
        scrambleToggle: document.getElementById('scrambleToggle'),

        // Modals
        qrModal: document.getElementById('qrModal'),
        qrCanvas: document.getElementById('qrCanvas'),
        shareUrlInput: document.getElementById('shareUrlInput'),
        copyLinkBtn: document.getElementById('copyLinkBtn'),

        addPeerModal: document.getElementById('addPeerModal'),
        remoteIdInput: document.getElementById('remoteIdInput'),
        connectSubmitBtn: document.getElementById('connectSubmitBtn'),

        createGroupModal: document.getElementById('createGroupModal'),
        groupNameInput: document.getElementById('groupNameInput'),
        createGroupSubmitBtn: document.getElementById('createGroupSubmitBtn'),

        groupAddMemberModal: document.getElementById('groupAddMemberModal'),
        groupMemberIdInput: document.getElementById('groupMemberIdInput'),
        groupAddMemberSubmitBtn: document.getElementById('groupAddMemberSubmitBtn'),

        settingsModal: document.getElementById('settingsModal'),
        secureSessionToggle: document.getElementById('secureSessionToggle'),
        allowFilesToggle: document.getElementById('allowFilesToggle'),
        useOpenRelayToggle: document.getElementById('useOpenRelayToggle'),
        forceRelayToggle: document.getElementById('forceRelayToggle'),
        turnUrlInput: document.getElementById('turnUrlInput'),
        turnUserInput: document.getElementById('turnUserInput'),
        turnPassInput: document.getElementById('turnPassInput'),
        saveTurnBtn: document.getElementById('saveTurnBtn'),

        keyModal: document.getElementById('keyModal'),
        keyModalTitle: document.getElementById('keyModalTitle'),
        keyInput: document.getElementById('keyInput'),
        saveKeyBtn: document.getElementById('saveKeyBtn'),

        rawDataModal: document.getElementById('rawDataModal'),
        rawDataContent: document.getElementById('rawDataContent'),

        fileInfoModal: document.getElementById('fileInfoModal'),
        fiName: document.getElementById('fiName'),
        fiType: document.getElementById('fiType'),
        fiSize: document.getElementById('fiSize'),
        fiHash: document.getElementById('fiHash'),

        // Drawing
        drawingModal: document.getElementById('drawingModal'),
        drawingCanvas: document.getElementById('drawingCanvas'),
        canvasContainer: document.getElementById('canvasContainer'),
        finishDrawingBtn: document.getElementById('finishDrawingBtn'),
        cancelDrawingBtn: document.getElementById('cancelDrawingBtn'),
        colorDots: document.querySelectorAll('.color-dot'),

        // Morse
        morseOverlay: document.getElementById('morseOverlay'),
        closeMorseBtn: document.getElementById('closeMorseBtn'),
        morseTapBtn: document.getElementById('morseTapBtn'),
        morseStatus: document.getElementById('morseStatus')
      };

      // --- INITIALIZATION ---
      document.addEventListener('DOMContentLoaded', async () => {
        setupEventListeners();
        ensureDrawingInitialized();
        renderVk();

        const params = new URLSearchParams(window.location.search);
        const connectTo = normalizePeerId(params.get('connect') || '');
        const keyParam = params.get('key');

        if (connectTo) {
          // INSTANT LOGIN BYPASS
          const randomId = generateRandomId();
          els.loginScreen.style.display = 'none';
          els.app.classList.add('visible');

          pendingConnect = { id: connectTo, key: keyParam };
          await initializeSystem(randomId);
        } else {
          await initializeSystem();
        }
      });

      async function initializeSystem(forceId = null) {
        try { await initDB(); }
        catch(e) { console.warn("IndexedDB failed, falling back to memory mode.", e); }

        myFingerprint = await generateFingerprint();
        logSecurity(`My Fingerprint Hash: ${myFingerprint.substring(0, 16)}...`);

        await loadStorageAsync();

        if (forceId) {
          await initApp(forceId);
        }

        if (!heartbeatInterval) heartbeatInterval = setInterval(sendHeartbeat, 5000);

        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            reconnectAll();
          }
        });

        // If storage restored chats, render now
        renderChatList();
      }

      // --- GLARE CONTROL ---
      function preferredDirectionForPeer(peerId) {
        if (!myId) return 'in';
        return (String(myId) < String(peerId)) ? 'out' : 'in';
      }

      function adoptConnection(peerId, conn, dir) {
        const existing = connRegistry.get(peerId);
        conn.__dir = dir;
        conn.__createdAt = Date.now();

        if (existing && existing.conn === conn) return true;

        if (!existing) {
          connRegistry.set(peerId, { conn, dir, createdAt: conn.__createdAt });
          return true;
        }

        if (existing.conn && existing.conn.open) {
          try { conn.close(); } catch {}
          return false;
        }

        if (conn.open) {
          try { existing.conn.close(); } catch {}
          connRegistry.set(peerId, { conn, dir, createdAt: conn.__createdAt });
          return true;
        }

        const pref = preferredDirectionForPeer(peerId);
        if (dir === pref && existing.dir !== pref) {
          try { existing.conn.close(); } catch {}
          connRegistry.set(peerId, { conn, dir, createdAt: conn.__createdAt });
          return true;
        }

        try { conn.close(); } catch {}
        return false;
      }

      function reconnectAll() {
        if (!peer) return;
        if (peer.disconnected) {
          peer.reconnect();
          logDebug("App woke up. Reconnecting to signaling server...");
        }
        chats.forEach(chat => {
          if (chat.type === 'direct' && (!chat.conn || !chat.conn.open)) {
            if (!chat.dialInProgress) {
              const jitter = 300 + Math.floor(Math.random() * 900);
              setTimeout(() => connectToPeer(chat.id, chat.passphrase), jitter);
              logDebug(`Attempting to rejoin ${chat.name}...`);
            }
          }
        });
      }

      // --- URL ENCODING HELPERS ---
      function b64urlEncodeUtf8(str) {
        const bytes = new TextEncoder().encode(str);
        let bin = '';
        for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
        const b64 = btoa(bin);
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }
      function b64urlDecodeUtf8(b64url) {
        const b64 = (b64url || '').replace(/-/g, '+').replace(/_/g, '/')
          .padEnd(Math.ceil((b64url || '').length / 4) * 4, '=');
        const bin = atob(b64);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        return new TextDecoder().decode(bytes);
      }

      function handleAutoConnect(connectTo, keyParam) {
        let decodedKey = settings.defaultPassphrase || 'changeme';
        if (keyParam) {
          try { decodedKey = b64urlDecodeUtf8(keyParam); }
          catch (e) { logDebug("Key decode failed: " + e.message, 'error'); }
        }

        let chat = chats.get(connectTo);
        if (!chat) {
          chat = createChatObject(connectTo, decodedKey);
          chats.set(connectTo, chat);
          renderChatList();
        } else {
          chat.passphrase = decodedKey || chat.passphrase;
        }

        setActiveChat(connectTo);
        connectToPeer(connectTo, decodedKey);
        window.history.replaceState({}, document.title, window.location.pathname);
      }

      // --- EVENT LISTENERS ---
      function setupEventListeners() {
        // Login
        els.loginForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          els.loginBtn.textContent = "Starting...";
          els.loginBtn.disabled = true;

          let val = (els.customIdInput.value || '').trim().replace(/[^a-zA-Z0-9-_]/g, '');
          if (!val) val = generateRandomId();
          await initApp(val);
        });

        // Sidebar & Overlay
        const toggleSidebar = () => {
          const isOpen = els.sidebar.classList.contains('open');
          els.sidebar.classList.toggle('open', !isOpen);
          els.sidebarOverlay.classList.toggle('visible', !isOpen);
        };
        els.menuBtn.addEventListener('click', toggleSidebar);
        els.sidebarOverlay.addEventListener('click', toggleSidebar);

        els.showQrBtn.addEventListener('click', showQrModal);
        els.addPeerBtn.addEventListener('click', () => openModal(els.addPeerModal));
        els.createGroupBtn.addEventListener('click', () => openModal(els.createGroupModal));
        els.settingsBtn.addEventListener('click', () => openModal(els.settingsModal));

        els.copyMyIdBtn.addEventListener('click', async () => {
          if (!myId) return;
          await safeCopyText(myId);
          els.copyMyIdBtn.classList.remove('fa-copy');
          els.copyMyIdBtn.classList.add('fa-check');
          setTimeout(() => {
            els.copyMyIdBtn.classList.remove('fa-check');
            els.copyMyIdBtn.classList.add('fa-copy');
          }, 1500);
        });

        // Chat Actions
        els.msgForm.addEventListener('submit', (e) => { e.preventDefault(); sendMessage(); });
        els.msgInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });

        els.uploadBtn.addEventListener('click', () => els.fileInput.click());
        els.fileInput.addEventListener('change', handleFileUpload);

        els.drawBtn.addEventListener('click', () => startDrawingSession(false));

        // Audio Recording Events
        els.micBtn.addEventListener('mousedown', startRecording);
        els.micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); }, { passive: false });
        els.micBtn.addEventListener('mouseup', stopRecording);
        els.micBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); }, { passive: false });
        els.micBtn.addEventListener('mouseleave', () => { if (isRecording) stopRecording(); });

        // Morse Events
        els.morseBtn.addEventListener('click', openMorseMode);
        els.closeMorseBtn.addEventListener('click', closeMorseMode);
        els.morseTapBtn.addEventListener('mousedown', startMorseTap);
        els.morseTapBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startMorseTap(); }, { passive: false });
        els.morseTapBtn.addEventListener('mouseup', endMorseTap);
        els.morseTapBtn.addEventListener('touchend', (e) => { e.preventDefault(); endMorseTap(); }, { passive: false });
        els.morseTapBtn.addEventListener('mouseleave', endMorseTap);

        // Ghost
        els.ghostToggle.addEventListener('click', () => {
          ghostMode = !ghostMode;
          els.ghostToggle.classList.toggle('active', ghostMode);
          addSystemMessage(getActiveChat(), ghostMode ? "üëª Ghost Mode ON" : "Ghost Mode OFF");
        });

        // Key Settings (now works even with no chat selected -> default key)
        els.keySettingsBtn.addEventListener('click', () => {
          const chat = getActiveChat();
          if (chat) {
            els.keyModal.dataset.mode = 'chat';
            els.keyModalTitle.textContent = "Encryption Key (This Chat)";
            els.keyInput.value = chat.passphrase || settings.defaultPassphrase || 'changeme';
          } else {
            els.keyModal.dataset.mode = 'default';
            els.keyModalTitle.textContent = "Default Encryption Key";
            els.keyInput.value = settings.defaultPassphrase || 'changeme';
          }
          openModal(els.keyModal);
        });

        els.deleteChatBtn.addEventListener('click', () => {
          const chat = getActiveChat();
          if (!chat) return;
          if (confirm('NUKE CHAT? This will clear history for BOTH you and the peer. This cannot be undone.')) {
            sendSignal(chat, { type: 'clear_history' });
            chat.messages = [];
            incomingFiles = {};
            renderMessages(chat);
            saveStorage();
          }
        });

        els.reconnectBtn.addEventListener('click', () => {
          const chat = getActiveChat();
          if (chat && chat.type === 'direct') {
            logDebug("Force Reconnect triggered by user.");
            if (chat.conn) { try { chat.conn.close(); } catch {} }
            connRegistry.delete(chat.id);
            chat.dialInProgress = false;
            chat.iceState = 'new';
            connectToPeer(chat.id, chat.passphrase);
          }
        });

        // Logs
        els.logHeader.addEventListener('click', (e) => {
          if (e.target !== els.viewRawDataBtn && !e.target.classList.contains('log-tab')) {
            els.securityLog.classList.toggle('open');
          }
        });
        els.debugToggleBtn.addEventListener('click', () => {
          els.securityLog.classList.toggle('open');
        });
        els.viewRawDataBtn.addEventListener('click', () => {
          els.rawDataContent.textContent = JSON.stringify(myFingerprintRaw, null, 2);
          openModal(els.rawDataModal);
        });
        els.tabSec.addEventListener('click', () => switchLogTab('sec'));
        els.tabDebug.addEventListener('click', () => switchLogTab('debug'));

        // Virtual Keyboard
        els.vkToggleBtn.addEventListener('click', () => {
          vkActive = !vkActive;
          els.virtualKeyboard.classList.toggle('open', vkActive);
          els.vkToggleBtn.classList.toggle('active', vkActive);
        });
        els.vkTabs.forEach(tab => {
          tab.addEventListener('click', () => {
            els.vkTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            vkSet = tab.dataset.set;
            renderVk();
          });
        });
        els.scrambleToggle.addEventListener('change', (e) => {
          vkScramble = e.target.checked;
          renderVk();
        });

        // Modals
        els.connectSubmitBtn.addEventListener('click', () => {
          const id = normalizePeerId(els.remoteIdInput.value.trim());
          if (id) { connectToPeer(id); closeModals(); }
        });
        els.createGroupSubmitBtn.addEventListener('click', () => {
          const name = (els.groupNameInput.value || '').trim();
          if (name) { createGroup(name); closeModals(); }
        });
        els.groupAddMemberSubmitBtn.addEventListener('click', () => {
          const id = normalizePeerId(els.groupMemberIdInput.value.trim());
          if (id) { addMemberToGroup(id); closeModals(); }
        });
        els.copyLinkBtn.addEventListener('click', async () => {
          await safeCopyText(els.shareUrlInput.value || '');
          els.copyLinkBtn.textContent = "Copied!";
          setTimeout(() => els.copyLinkBtn.textContent = "Copy Link", 2000);
        });

        els.saveKeyBtn.addEventListener('click', () => {
          const newKey = (els.keyInput.value || '').trim() || 'changeme';
          const mode = els.keyModal.dataset.mode || 'chat';
          const chat = getActiveChat();

          if (mode === 'default' || !chat) {
            settings.defaultPassphrase = newKey;
            saveStorage();
            addSystemMessage(getActiveChat(), `Default key updated.`);
            closeModals();
            return;
          }

          chat.passphrase = newKey;
          if (chat.type === 'group') {
            chat.participants.forEach(pid => {
              const conn = chat.connections[pid];
              if (conn && conn.open) conn.send({ kind: 'system', type: 'key_change', text: 'Group key changed.' , groupId: chat.id, groupName: chat.name });
            });
          } else if (chat.conn && chat.conn.open) {
            chat.conn.send({ kind: 'system', type: 'key_change', text: 'Peer changed key.' });
          }
          addSystemMessage(chat, `Key updated.`);
          saveStorage();
          closeModals();
        });

        // Settings
        els.secureSessionToggle.addEventListener('change', (e) => {
          settings.secureSession = e.target.checked;
          saveStorage();
          logSecurity(`Secure Session: ${settings.secureSession ? 'ENABLED' : 'DISABLED'}`);
        });
        els.allowFilesToggle.addEventListener('change', (e) => {
          settings.allowFiles = e.target.checked;
          saveStorage();
        });
        els.useOpenRelayToggle.addEventListener('change', (e) => {
          settings.useOpenRelay = e.target.checked;
          saveStorage();
        });
        els.forceRelayToggle.addEventListener('change', (e) => {
          settings.forceRelay = e.target.checked;
          saveStorage();
        });

        els.saveTurnBtn.addEventListener('click', async () => {
          settings.turnUrl = (els.turnUrlInput.value || '').trim();
          settings.turnUser = (els.turnUserInput.value || '').trim();
          settings.turnPass = (els.turnPassInput.value || '').trim();
          saveStorage();
          await rebuildPeerAndReconnect();
          closeModals();
        });
      }

      // --- LOGGING SYSTEM ---
      function switchLogTab(tab) {
        activeLogTab = tab;
        els.tabSec.classList.toggle('active', tab === 'sec');
        els.tabDebug.classList.toggle('active', tab === 'debug');
        renderLogs();
      }

      let logs = { sec: [], debug: [] };

      function logSecurity(msg, type = 'info') {
        logs.sec.push({ msg, type, time: new Date().toLocaleTimeString() });
        if (activeLogTab === 'sec') renderLogs();
      }

      function logDebug(msg, type = 'info') {
        logs.debug.push({ msg, type, time: new Date().toLocaleTimeString() });
        if (activeLogTab === 'debug') renderLogs();
      }

      function renderLogs() {
        els.logContent.innerHTML = '';
        const currentLogs = logs[activeLogTab] || [];
        currentLogs.forEach(l => {
          const row = document.createElement('div');
          row.className = `log-row ${l.type}`;
          row.innerHTML = `<span style="color:#555; font-size:9px;">${l.time}</span> <span class="log-hash">${sanitize(l.msg)}</span>`;
          els.logContent.appendChild(row);
        });
        els.logContent.scrollTop = els.logContent.scrollHeight;
      }

      // --- FINGERPRINTING ---
      async function generateFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = "top";
        ctx.font = "14px 'Arial'";
        ctx.fillStyle = "#f60";
        ctx.fillRect(125,1,62,20);
        ctx.fillStyle = "#069";
        ctx.fillText("PepeChatv141", 2, 15);
        const b64 = canvas.toDataURL();

        const components = [
          "UserAgent: " + navigator.userAgent,
          "Language: " + navigator.language,
          "Timezone: " + new Date().getTimezoneOffset(),
          "Concurrency: " + (navigator.hardwareConcurrency || 'unknown'),
          "CanvasHash: " + b64.substring(0, 30) + "..."
        ];

        myFingerprintRaw = components;

        const str = components.join('||');
        const enc = new TextEncoder();
        const hashBuf = await crypto.subtle.digest('SHA-256', enc.encode(str));
        return buf2hex(hashBuf);
      }

      // --- TURN (OpenRelay) Credentials (HMAC-SHA1 / TURN REST style) ---
      async function hmacSha1Base64(secret, message) {
        const enc = new TextEncoder();
        const key = await crypto.subtle.importKey(
          'raw',
          enc.encode(secret),
          { name: 'HMAC', hash: 'SHA-1' },
          false,
          ['sign']
        );
        const sig = await crypto.subtle.sign('HMAC', key, enc.encode(message));
        const bytes = new Uint8Array(sig);
        let bin = '';
        for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
        return btoa(bin);
      }

      async function buildIceServers() {
        const servers = [...DEFAULT_ICE];

        // OpenRelay TURN (optional but ON by default)
        if (settings.useOpenRelay) {
          const unix = Math.floor(Date.now() / 1000) + (OPENRELAY.ttlSeconds || 3600);
          const username = `${unix}:${myId || 'pepe'}`;
          const credential = await hmacSha1Base64(OPENRELAY.secret, username);

          servers.push({
            urls: [
              `turn:${OPENRELAY.host}:80`,
              `turn:${OPENRELAY.host}:443`,
              `turns:${OPENRELAY.host}:443?transport=tcp`
            ],
            username,
            credential
          });

          // Also add STUN on same infra (works even if TURN not used)
          servers.push({ urls: `stun:${OPENRELAY.host}:80` });
        }

        // Custom TURN (user-provided)
        if (settings.turnUrl) {
          servers.push({
            urls: settings.turnUrl,
            username: settings.turnUser || undefined,
            credential: settings.turnPass || undefined
          });
        }

        return servers;
      }

      function getRtcConfig(iceServers) {
        return {
          iceServers,
          iceCandidatePoolSize: 10,
          iceTransportPolicy: settings.forceRelay ? 'relay' : 'all',
          sdpSemantics: 'unified-plan'
        };
      }

      // --- PEER INIT / REBUILD ---
      async function initApp(userId) {
        if (!window.RTCPeerConnection) {
          alert("WebRTC is not available in this browser (Tor may block it).");
          logSecurity("Browser incompatible: RTCPeerConnection missing.", 'error');
          return;
        }

        myId = userId;
        els.myNameDisplay.textContent = userId;
        els.myIdDisplay.textContent = "ID: " + userId;
        els.myAvatar.textContent = userId.substring(0,2).toUpperCase();

        logDebug(`Initializing PeerJS with ID: ${userId}`);
        logDebug(`Configuring ICE (STUN/TURN) for NAT traversal...`);

        const iceServers = await buildIceServers();
        const rtcConfig = getRtcConfig(iceServers);

        // Destroy existing peer if any (safe)
        if (peer) {
          try { peer.destroy(); } catch {}
          peer = null;
        }

        peer = new Peer(myId, {
          debug: 2,
          config: rtcConfig
        });

        peer.on('open', (id) => {
          myId = id;
          els.myIdDisplay.textContent = "ID: " + id;

          els.loginScreen.classList.add('hidden');
          setTimeout(() => els.loginScreen.style.display = 'none', 250);
          els.app.classList.add('visible');

          logSecurity("Peer Network Connected.");

          // Auto-connect if QR deep-link was used
          if (pendingConnect) {
            handleAutoConnect(pendingConnect.id, pendingConnect.key);
            pendingConnect = null;
          }

          // Re-render
          renderChatList();
        });

        peer.on('disconnected', () => {
          logDebug("PeerJS signaling disconnected. Attempting reconnect...", 'warn');
          try { peer.reconnect(); } catch {}
        });

        peer.on('close', () => {
          logDebug("PeerJS closed.", 'warn');
        });

        peer.on('error', async (err) => {
          logDebug(`Peer Error: ${err.type} - ${err.message}`, 'error');

          if (err.type === 'unavailable-id') {
            alert('ID taken. Trying random.');
            try { peer.destroy(); } catch {}
            await initApp(generateRandomId());
          } else if (err.type === 'peer-unavailable') {
            alert('Peer not found. They might be offline or the ID is incorrect.');
          } else if (err.type === 'browser-incompatible') {
            logSecurity("Browser incompatible. If on Tor, WebRTC might be blocked.", 'error');
          }
        });

        peer.on('connection', (conn) => {
          logDebug(`Incoming connection from ${conn.peer}`);
          handleConnection(conn, true);
        });

        // If storage had chats, attempt reconnect lightly
        setTimeout(reconnectAll, 300);
      }

      async function rebuildPeerAndReconnect() {
        // Snapshot peers to reconnect
        const toReconnect = [];
        chats.forEach(chat => {
          if (chat.type === 'direct') {
            toReconnect.push({ id: chat.id, key: chat.passphrase });
          }
          if (chat.conn) { try { chat.conn.close(); } catch {} }
          chat.conn = null;
          chat.iceState = 'new';
          chat.dialInProgress = false;
        });
        connRegistry.clear();

        // Re-init peer with same ID if possible
        const keepId = myId || generateRandomId();
        logDebug("Rebuilding PeerJS with updated ICE config...");
        await initApp(keepId);

        // Re-dial
        setTimeout(() => {
          toReconnect.forEach((p, idx) => {
            const jitter = 300 + idx * 250 + Math.floor(Math.random() * 400);
            setTimeout(() => connectToPeer(p.id, p.key), jitter);
          });
        }, 800);
      }

      // --- PEER CONNECT ---
      function connectToPeer(remoteId, presetKey) {
        remoteId = normalizePeerId(remoteId || '');
        if (!remoteId || remoteId === myId) return;
        if (!peer) { logDebug("Peer not ready yet.", 'warn'); return; }

        let chat = chats.get(remoteId);
        if (!chat) {
          chat = createChatObject(remoteId, presetKey);
          chats.set(remoteId, chat);
          renderChatList();
        }

        if (presetKey) chat.passphrase = presetKey;

        if (chat.dialInProgress) {
          logDebug(`Dial already in progress for ${remoteId}`);
          return;
        }

        if (chat.conn && chat.conn.open) {
          setActiveChat(remoteId);
          return;
        }

        chat.dialInProgress = true;
        chat.iceState = 'checking';
        setActiveChat(remoteId);
        updateChatStatus(chat);
        logDebug(`Initiating connection to ${remoteId}...`);

        // IMPORTANT: Include PSK in metadata so inbound side can set the same key (fixes QR + new chat key mismatch)
        const pskB64 = b64urlEncodeUtf8(chat.passphrase || settings.defaultPassphrase || 'changeme');

        const conn = peer.connect(remoteId, {
          reliable: true,
          serialization: 'json',
          metadata: { from: myId, ts: Date.now(), psk: pskB64 }
        });

        const timeout = setTimeout(() => {
          if (!conn.open) {
            logDebug(`Connection to ${remoteId} timed out (45s). NAT/Firewall issue likely.`, 'error');
            try { conn.close(); } catch {}
            chat.dialInProgress = false;
            chat.iceState = 'failed';
            updateChatStatus(chat);
            renderChatList();
          }
        }, 45000);

        conn.on('open', () => {
          clearTimeout(timeout);
          chat.dialInProgress = false;
        });
        conn.on('error', (err) => {
          clearTimeout(timeout);
          chat.dialInProgress = false;
          chat.iceState = 'failed';
          logDebug(`Conn Error (${remoteId}): ${(err && err.message) ? err.message : String(err)}`, 'error');
          updateChatStatus(chat);
        });

        handleConnection(conn, false, presetKey);
      }

      function handleConnection(conn, inbound, presetKey) {
        const peerId = normalizePeerId(conn.peer || '');
        if (!peerId) return false;

        // Pull PSK from metadata if present (fixes QR and "new incoming chat has wrong key")
        let pskFromMeta = null;
        try {
          if (conn.metadata && conn.metadata.psk) pskFromMeta = b64urlDecodeUtf8(conn.metadata.psk);
        } catch {}

        let chat = chats.get(peerId);

        if (!chat) {
          chat = createChatObject(peerId, presetKey || pskFromMeta || settings.defaultPassphrase);
          chats.set(peerId, chat);
        } else {
          if (presetKey) chat.passphrase = presetKey;
          else if (pskFromMeta && (chat.passphrase === 'changeme' || chat.passphrase === (settings.defaultPassphrase || 'changeme'))) {
            chat.passphrase = pskFromMeta;
          }
        }

        const dir = inbound ? 'in' : 'out';
        if (!adoptConnection(peerId, conn, dir)) {
          logDebug(`Dropped ${dir} connection from/to ${peerId} (duplicate/glare policy)`, 'warn');
          return false;
        }

        chat.conn = conn;
        chat.iceState = 'checking';
        chat.dialInProgress = false;

        renderChatList();
        if (!activeChatId) setActiveChat(peerId);

        // --- HARD DIAGNOSTICS ---
        const monitorICE = () => {
          const pc = conn.peerConnection || conn._pc || null;
          if (!pc) return setTimeout(monitorICE, 100);

          if (pc.__pepeBound) return;
          pc.__pepeBound = true;

          pc.addEventListener('icecandidate', (event) => {
            if (event.candidate) logDebug(`ICE Candidate (${peerId}): ${event.candidate.candidate}`);
          });
          pc.addEventListener('icecandidateerror', (e) => {
            logDebug(`ICE Candidate Error (${peerId}): ${e.errorCode} ${e.errorText}`, 'error');
          });
          pc.addEventListener('iceconnectionstatechange', () => {
            logDebug(`ICE State (${peerId}): ${pc.iceConnectionState}`);
            chat.iceState = pc.iceConnectionState || chat.iceState;
            updateChatStatus(chat);

            if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'closed') {
              dumpIceStats(pc, peerId).catch(() => {});
            }
          });
          pc.addEventListener('connectionstatechange', () => {
            logDebug(`PC State (${peerId}): ${pc.connectionState}`);
          });
        };
        monitorICE();

        async function dumpIceStats(pc, peerId) {
          if (!pc || typeof pc.getStats !== 'function') return;
          const stats = await pc.getStats();
          let hasRelay = false;
          stats.forEach(r => {
            if (r.type === 'local-candidate' && r.candidateType === 'relay') hasRelay = true;
          });
          if (!hasRelay) {
            logDebug(`TURN WARNING (${peerId}): No relay candidates. Enable OpenRelay or add TURN in Settings.`, 'warn');
          }
        }

        conn.on('open', () => {
          logDebug(`DataChannel established with ${peerId}`);
          chat.conn = conn;
          chat.lastSeen = Date.now();
          chat.dialInProgress = false;
          chat.iceState = 'connected';

          if (els.qrModal.classList.contains('open')) closeModals();

          conn.send({
            kind: 'handshake',
            name: myId,
            fingerprint: myFingerprint
          });

          updateChatStatus(chat);
          renderChatList();

          if (chat.pendingMessages.length > 0) {
            addSystemMessage(chat, "Connection re-established. Sending queued messages...");
            chat.pendingMessages.forEach(item => {
              encryptPayload(chat.passphrase, item.payload).then(pkg => {
                conn.send({
                  kind: 'message',
                  iv: pkg.iv,
                  data: pkg.data,
                  senderName: myId,
                  timestamp: item.timestamp
                });
              });
              const uiMsg = chat.messages.find(m => m.id === item.msgId);
              if (uiMsg) {
                uiMsg.status = 'sent';
                if (activeChatId === chat.id) {
                  const el = document.getElementById(uiMsg.id);
                  if (el) {
                    const statusEl = el.querySelector('.msg-status');
                    if (statusEl) statusEl.innerHTML = '<i class="fa-solid fa-check"></i>';
                  }
                }
              }
            });
            chat.pendingMessages = [];
          }
        });

        conn.on('data', (data) => handleData(conn, data));
        conn.on('close', () => {
          logDebug(`Connection closed: ${peerId}`);
          chat.dialInProgress = false;
          chat.iceState = 'closed';

          const reg = connRegistry.get(peerId);
          if (reg && reg.conn === conn) connRegistry.delete(peerId);

          updateChatStatus(chat);
          renderChatList();
        });

        // Better retry strategy (jitter + small backoff)
        conn.on('error', (err) => {
          const msg = (err && err.message) ? err.message : String(err);
          logDebug(`Conn Error (${peerId}): ${msg}`, 'error');
          chat.dialInProgress = false;
          chat.iceState = 'failed';
          updateChatStatus(chat);

          const lower = msg.toLowerCase();
          const isNegotiation = lower.includes('negotiation') || lower.includes('sdp') || lower.includes('offer') || lower.includes('answer');
          if (isNegotiation) {
            try { conn.close(); } catch {}
            connRegistry.delete(peerId);

            chat.__retryCount = (chat.__retryCount || 0) + 1;
            const backoff = Math.min(2500, 300 + chat.__retryCount * 400) + Math.floor(Math.random() * 600);

            logDebug(`Negotiation failed. Retrying in ${backoff}ms...`, 'warn');
            setTimeout(() => {
              if (chat && chat.type === 'direct') connectToPeer(peerId, chat.passphrase);
            }, backoff);
          }
        });

        return true;
      }

      function createChatObject(peerId, presetKey) {
        return {
          id: peerId,
          name: peerId,
          type: 'direct',
          passphrase: presetKey || settings.defaultPassphrase || 'changeme',
          messages: [],
          pendingMessages: [],
          conn: null,
          unread: 0,
          fingerprint: null,
          lastSeen: 0,
          iceState: 'new',
          dialInProgress: false,
          __retryCount: 0
        };
      }

      // --- HEARTBEAT ---
      function sendHeartbeat() {
        chats.forEach(chat => {
          if (chat.type === 'direct' && chat.conn && chat.conn.open) {
            chat.conn.send({ kind: 'ping' });
            if (Date.now() - (chat.lastSeen || 0) > 20000) {
              updateChatStatus(chat);
            }
          }
        });
      }

      // --- GROUP CHAT LOGIC ---
      function createGroup(name) {
        const groupId = 'group-' + Date.now();
        const chat = {
          id: groupId,
          name: name,
          type: 'group',
          passphrase: settings.defaultPassphrase || 'changeme',
          messages: [],
          participants: [],
          connections: {},
          unread: 0
        };
        chats.set(groupId, chat);
        setActiveChat(groupId);
        addSystemMessage(chat, 'Group created.');
        saveStorage();
      }

      function addMemberToGroup(peerId) {
        const chat = getActiveChat();
        if (!chat || chat.type !== 'group') return;
        if (chat.participants.includes(peerId)) return;
        if (!peer) return;

        const conn = peer.connect(peerId, { serialization: 'json', reliable: true, metadata: { from: myId, ts: Date.now() } });
        chat.participants.push(peerId);
        chat.connections[peerId] = conn;

        conn.on('open', () => {
          conn.send({
            kind: 'handshake',
            name: myId,
            fingerprint: myFingerprint,
            groupId: chat.id,
            groupName: chat.name
          });
          addSystemMessage(chat, `${peerId} added.`);
        });
        conn.on('data', (data) => handleData(conn, data));
        conn.on('close', () => { delete chat.connections[peerId]; chat.participants = chat.participants.filter(x => x !== peerId); renderChatList(); });
        saveStorage();
      }

      // --- DATA HANDLING ---
      function handleData(conn, data) {
        let chat = null;

        if (data && data.groupId) {
          chat = chats.get(data.groupId);
          if (!chat) {
            chat = {
              id: data.groupId,
              name: data.groupName || 'Unknown Group',
              type: 'group',
              passphrase: settings.defaultPassphrase || 'changeme',
              messages: [],
              participants: [conn.peer],
              connections: { [conn.peer]: conn },
              unread: 0
            };
            chats.set(data.groupId, chat);
            renderChatList();
          } else {
            if (!chat.connections[conn.peer]) chat.connections[conn.peer] = conn;
            if (!chat.participants.includes(conn.peer)) chat.participants.push(conn.peer);
          }
        } else {
          chat = chats.get(conn.peer);
        }

        if (!chat || !data) return;

        chat.lastSeen = Date.now();

        if (data.kind === 'ping') { conn.send({ kind: 'pong', groupId: chat.type === 'group' ? chat.id : undefined }); updateChatStatus(chat); return; }
        if (data.kind === 'pong') { updateChatStatus(chat); return; }

        if (data.kind === 'signal') {
          if (data.type === 'clear_history') {
            chat.messages = [];
            incomingFiles = {};
            addSystemMessage(chat, "Peer nuked the chat history.");
            if (activeChatId === chat.id) renderMessages(chat);
          } else if (data.type === 'drawing_invite') {
            const accept = confirm(`${conn.peer} is drawing. Join session?`);
            if (accept) {
              startDrawingSession(true);
              sendSignal(chat, { type: 'drawing_join' });
            }
          } else if (data.type === 'drawing_join') {
            addSystemMessage(chat, `${conn.peer} joined drawing session.`);
          } else if (data.type === 'drawing_stroke') {
            drawRemoteStroke(data.x, data.y, data.lastX, data.lastY, data.color);
          } else if (data.type === 'drawing_cursor') {
            showRemoteCursor(data.x, data.y, conn.peer);
          } else if (data.type === 'file_rejected') {
            addSystemMessage(chat, `Peer rejected file transfer (Settings disabled).`);
          }
          return;
        }

        if (data.kind === 'file_chunk') {
          handleFileChunk(chat, data);
          return;
        }

        if (data.kind === 'handshake') {
          if (chat.type === 'direct') {
            chat.name = data.name || chat.name;
            chat.conn = conn;

            if (settings.secureSession) {
              if (chat.fingerprint && chat.fingerprint !== data.fingerprint) {
                addSystemMessage(chat, `‚ö†Ô∏è SECURITY ALERT: Fingerprint mismatch!`);
                logSecurity(`ALERT: ${chat.name} fingerprint changed!`, 'error');
              } else {
                chat.fingerprint = data.fingerprint;
                logSecurity(`Verified ${chat.name}: ${(data.fingerprint || '').substring(0,16)}...`);
              }
            } else {
              chat.fingerprint = data.fingerprint;
              logSecurity(`Connected ${chat.name}: ${(data.fingerprint || '').substring(0,16)}...`);
            }
            updateChatStatus(chat);
          }
          renderChatList();
          if (activeChatId === chat.id) els.chatTitle.textContent = chat.name;
          return;
        }

        if (data.kind === 'system' && data.type === 'key_change') {
          const newKey = prompt(`Key change in ${chat.name}. Enter new key:`);
          if (newKey) chat.passphrase = newKey;
          saveStorage();
          return;
        }

        if (data.kind === 'message') {
          decryptMessage(chat.passphrase, data).then(payload => {
            if (!payload) return;
            const msgObj = {
              id: 'msg-' + Math.random().toString(36).slice(2, 11),
              chatId: chat.id,
              from: 'them',
              senderName: data.senderName || conn.peer,
              type: payload.type,
              content: payload.content,
              meta: payload.meta,
              timestamp: data.timestamp || new Date().toISOString(),
              ghost: payload.ghost,
              status: 'received'
            };
            chat.messages.push(msgObj);
            saveMessageToDB(msgObj);

            if (activeChatId === chat.id) {
              appendMessageToUI(msgObj);
            } else {
              chat.unread++;
              renderChatList();
            }
          });
        }
      }

      function sendSignal(chat, payload) {
        if (!chat) return;

        if (chat.type === 'direct') {
          if (chat.conn && chat.conn.open) chat.conn.send({ kind: 'signal', ...payload });
        } else if (chat.type === 'group') {
          chat.participants.forEach(pid => {
            const c = chat.connections[pid];
            if (c && c.open) c.send({ kind: 'signal', ...payload, groupId: chat.id, groupName: chat.name });
          });
        }
      }

      function sendMessage() {
        const text = (els.msgInput.value || '').trim();
        if (!text) return;

        const chat = getActiveChat();
        if (!chat) return;

        const payload = { type: 'text', content: text, ghost: ghostMode };
        const timestamp = new Date().toISOString();
        const msgId = 'msg-' + Math.random().toString(36).slice(2, 11);

        const msgObj = {
          id: msgId,
          chatId: chat.id,
          from: 'me',
          type: 'text',
          content: text,
          timestamp: timestamp,
          ghost: ghostMode,
          status: 'pending'
        };
        chat.messages.push(msgObj);
        saveMessageToDB(msgObj);
        appendMessageToUI(msgObj);
        els.msgInput.value = '';

        encryptPayload(chat.passphrase, payload).then(pkg => {
          const msgData = {
            kind: 'message',
            iv: pkg.iv,
            data: pkg.data,
            groupId: chat.type === 'group' ? chat.id : undefined,
            groupName: chat.type === 'group' ? chat.name : undefined,
            senderName: myId,
            timestamp: timestamp
          };

          if (chat.type === 'direct') {
            if (chat.conn && chat.conn.open) {
              chat.conn.send(msgData);
              msgObj.status = 'sent';
              const el = document.getElementById(msgId);
              if (el) el.querySelector('.msg-status').innerHTML = '<i class="fa-solid fa-check"></i>';
            } else {
              chat.pendingMessages.push({ payload: payload, timestamp: timestamp, msgId: msgId });
            }
          } else {
            chat.participants.forEach(pid => {
              const c = chat.connections[pid];
              if (c && c.open) c.send(msgData);
            });
            msgObj.status = 'sent';
          }
        });
      }

      // --- AUDIO RECORDING ---
      function getAudioContext() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') audioContext.resume();
        return audioContext;
      }

      async function startRecording() {
        if (isRecording) return;
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
          mediaRecorder.onstop = processAudio;

          mediaRecorder.start();
          isRecording = true;
          els.micBtn.classList.add('recording');
          els.recordingOverlay.classList.add('visible');

          recStartTime = Date.now();
          recTimerInterval = setInterval(() => {
            const diff = Math.floor((Date.now() - recStartTime) / 1000);
            const m = Math.floor(diff / 60);
            const s = diff % 60;
            els.recTimer.textContent = `${m}:${s < 10 ? '0'+s : s}`;
          }, 1000);
        } catch(err) {
          alert("Microphone access denied or not available.");
          console.error(err);
        }
      }

      function stopRecording() {
        if (!isRecording || !mediaRecorder) return;
        mediaRecorder.stop();
        isRecording = false;
        els.micBtn.classList.remove('recording');
        els.recordingOverlay.classList.remove('visible');
        clearInterval(recTimerInterval);
        els.recTimer.textContent = "0:00";

        try { mediaRecorder.stream.getTracks().forEach(track => track.stop()); } catch {}
      }

      function processAudio() {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        if (audioBlob.size < 1000) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const base64 = e.target.result;
          sendAudioMessage(base64);
        };
        reader.readAsDataURL(audioBlob);
      }

      function sendAudioMessage(base64) {
        const chat = getActiveChat();
        if (!chat) return;

        const meta = { name: 'voice_msg.webm', size: 'Audio', type: 'audio/webm', hash: 'generated' };
        const payload = { type: 'audio', content: base64, meta: meta, ghost: ghostMode };
        const timestamp = new Date().toISOString();
        const msgId = 'msg-' + Math.random().toString(36).slice(2, 11);

        const msgObj = { id: msgId, chatId: chat.id, from: 'me', type: 'audio', content: base64, meta: meta, timestamp: timestamp, ghost: ghostMode, status: 'pending', progress: 0 };
        chat.messages.push(msgObj);
        saveMessageToDB(msgObj);
        appendMessageToUI(msgObj);

        encryptPayload(chat.passphrase, payload).then(pkg => {
          sendFileChunked(chat, pkg, timestamp, msgObj);
        });
      }

      // --- MORSE MODE ---
      function openMorseMode() {
        els.morseOverlay.classList.add('visible');
        morseActive = true;
        morseSequence = [];
        getAudioContext();
      }

      function closeMorseMode() {
        els.morseOverlay.classList.remove('visible');
        morseActive = false;
        clearTimeout(morseTimeout);
      }

      function startMorseTap() {
        if (!morseActive) return;
        els.morseTapBtn.classList.add('active');

        const ctx = getAudioContext();
        morseOscillator = ctx.createOscillator();
        morseGain = ctx.createGain();
        morseOscillator.connect(morseGain);
        morseGain.connect(ctx.destination);
        morseOscillator.frequency.value = 600;
        morseOscillator.start();

        morseStartTime = Date.now();
        clearTimeout(morseTimeout);
        els.morseStatus.textContent = "Recording...";
      }

      function endMorseTap() {
        if (!morseActive || !morseOscillator) return;
        els.morseTapBtn.classList.remove('active');

        try { morseOscillator.stop(); } catch {}
        morseOscillator = null;

        const duration = Date.now() - morseStartTime;
        if (duration > 10) morseSequence.push(duration);

        morseTimeout = setTimeout(sendMorseSequence, 3000);
      }

      function sendMorseSequence() {
        if (morseSequence.length < 1) return;

        if (morseSequence.length === 1 && morseSequence[0] < 50) {
          morseSequence = [];
          els.morseStatus.textContent = "Ignored (Too short)";
          return;
        }

        const chat = getActiveChat();
        if (chat) {
          const payload = { type: 'morse', content: JSON.stringify(morseSequence), ghost: ghostMode };
          const timestamp = new Date().toISOString();
          const msgId = 'msg-' + Math.random().toString(36).slice(2, 11);

          const msgObj = { id: msgId, chatId: chat.id, from: 'me', type: 'morse', content: morseSequence, timestamp: timestamp, ghost: ghostMode, status: 'pending' };
          chat.messages.push(msgObj);
          saveMessageToDB(msgObj);
          appendMessageToUI(msgObj);

          encryptPayload(chat.passphrase, payload).then(pkg => {
            const msgData = {
              kind: 'message',
              iv: pkg.iv,
              data: pkg.data,
              groupId: chat.type === 'group' ? chat.id : undefined,
              groupName: chat.type === 'group' ? chat.name : undefined,
              senderName: myId,
              timestamp: timestamp
            };
            if (chat.type === 'direct' && chat.conn && chat.conn.open) {
              chat.conn.send(msgData);
              msgObj.status = 'sent';
              const el = document.getElementById(msgId);
              if (el) el.querySelector('.msg-status').innerHTML = '<i class="fa-solid fa-check"></i>';
            } else if (chat.type === 'group') {
              chat.participants.forEach(pid => {
                const c = chat.connections[pid];
                if (c && c.open) c.send(msgData);
              });
              msgObj.status = 'sent';
            }
          });

          els.morseStatus.textContent = "Sent!";
        }
        morseSequence = [];
      }

      function playMorseSequence(sequence) {
        const ctx = getAudioContext();
        let time = ctx.currentTime;

        sequence.forEach(dur => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.value = 600;

          osc.start(time);
          osc.stop(time + (dur / 1000));

          time += (dur / 1000) + 0.1;
        });
      }
      window.playMorseSequence = playMorseSequence; // FIX: make callable from inline onclick

      // --- DRAWING ---
      function ensureDrawingInitialized() {
        if (drawingInitialized) return;
        drawingInitialized = true;

        drawCtx = els.drawingCanvas.getContext('2d');

        // Pointer-based drawing (fixes broken touch/mouse mix)
        const getPos = (evt) => {
          const rect = els.drawingCanvas.getBoundingClientRect();
          const x = (evt.clientX - rect.left);
          const y = (evt.clientY - rect.top);
          return { x, y };
        };

        const pointerDown = (e) => {
          if (!drawingActive) return;
          els.drawingCanvas.setPointerCapture(e.pointerId);
          isDrawing = true;
          const p = getPos(e);
          lastX = p.x;
          lastY = p.y;
        };

        const pointerMove = (e) => {
          if (!drawingActive) return;
          const p = getPos(e);

          const chat = getActiveChat();
          const now = Date.now();
          if (chat && now - lastCursorSentAt > 40) {
            lastCursorSentAt = now;
            sendSignal(chat, { type: 'drawing_cursor', x: p.x / els.drawingCanvas.width, y: p.y / els.drawingCanvas.height });
          }

          if (!isDrawing) return;

          drawCtx.beginPath();
          drawCtx.moveTo(lastX, lastY);
          drawCtx.lineTo(p.x, p.y);
          drawCtx.strokeStyle = drawColor;
          drawCtx.lineWidth = 3;
          drawCtx.lineCap = 'round';
          drawCtx.stroke();

          if (chat) {
            sendSignal(chat, {
              type: 'drawing_stroke',
              x: p.x / els.drawingCanvas.width,
              y: p.y / els.drawingCanvas.height,
              lastX: lastX / els.drawingCanvas.width,
              lastY: lastY / els.drawingCanvas.height,
              color: drawColor
            });
          }

          lastX = p.x;
          lastY = p.y;
        };

        const pointerUp = (e) => {
          if (!drawingActive) return;
          isDrawing = false;
          try { els.drawingCanvas.releasePointerCapture(e.pointerId); } catch {}
        };

        els.drawingCanvas.addEventListener('pointerdown', pointerDown);
        els.drawingCanvas.addEventListener('pointermove', pointerMove);
        els.drawingCanvas.addEventListener('pointerup', pointerUp);
        els.drawingCanvas.addEventListener('pointercancel', pointerUp);

        els.colorDots.forEach(dot => {
          dot.addEventListener('click', () => {
            els.colorDots.forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            drawColor = dot.dataset.color;
          });
        });

        els.finishDrawingBtn.addEventListener('click', () => {
          const base64 = els.drawingCanvas.toDataURL('image/png');
          sendImageAsFile(base64, 'drawing.png');
          closeModals();
          drawingActive = false;
          isDrawing = false;
        });

        els.cancelDrawingBtn.addEventListener('click', () => {
          closeModals();
          drawingActive = false;
          isDrawing = false;
        });

        window.addEventListener('resize', () => {
          if (drawingActive) resizeDrawingCanvas(true);
        });
      }

      function resizeDrawingCanvas(preserve = false) {
        const dpr = window.devicePixelRatio || 1;
        const w = els.canvasContainer.offsetWidth;
        const h = els.canvasContainer.offsetHeight;

        if (!preserve) {
          els.drawingCanvas.width = Math.floor(w * dpr);
          els.drawingCanvas.height = Math.floor(h * dpr);
          els.drawingCanvas.style.width = w + 'px';
          els.drawingCanvas.style.height = h + 'px';
          drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
          drawCtx.fillStyle = "white";
          drawCtx.fillRect(0, 0, w, h);
          return;
        }

        // preserve content
        const tmp = document.createElement('canvas');
        tmp.width = els.drawingCanvas.width;
        tmp.height = els.drawingCanvas.height;
        const tctx = tmp.getContext('2d');
        tctx.drawImage(els.drawingCanvas, 0, 0);

        els.drawingCanvas.width = Math.floor(w * dpr);
        els.drawingCanvas.height = Math.floor(h * dpr);
        els.drawingCanvas.style.width = w + 'px';
        els.drawingCanvas.style.height = h + 'px';
        drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

        drawCtx.fillStyle = "white";
        drawCtx.fillRect(0, 0, w, h);
        drawCtx.drawImage(tmp, 0, 0, tmp.width / dpr, tmp.height / dpr);
      }

      function startDrawingSession(isJoin = false) {
        const chat = getActiveChat();
        if (!chat) return;

        ensureDrawingInitialized();
        openModal(els.drawingModal);

        // Ensure canvas has correct size BEFORE drawing
        setTimeout(() => {
          resizeDrawingCanvas(false);
          drawingActive = true;

          if (!isJoin) {
            sendSignal(chat, { type: 'drawing_invite' });
            addSystemMessage(chat, "Started drawing session. Waiting for peer...");
          } else {
            drawColor = '#FF453A';
          }
        }, 60);
      }

      function drawRemoteStroke(x, y, lx, ly, color) {
        if (!drawingActive || !drawCtx) return;
        const w = els.drawingCanvas.width;
        const h = els.drawingCanvas.height;

        // Note: canvas is scaled by dpr; we draw in CSS pixels due to transform setTransform(dpr,...)
        const cssW = els.canvasContainer.offsetWidth;
        const cssH = els.canvasContainer.offsetHeight;

        drawCtx.beginPath();
        drawCtx.moveTo(lx * cssW, ly * cssH);
        drawCtx.lineTo(x * cssW, y * cssH);
        drawCtx.strokeStyle = color;
        drawCtx.lineWidth = 3;
        drawCtx.lineCap = 'round';
        drawCtx.stroke();
      }

      function safeCursorId(name) {
        return 'cursor-' + String(name || 'peer').replace(/[^a-zA-Z0-9_-]/g, '_').slice(0, 40);
      }

      function showRemoteCursor(x, y, name) {
        if (!drawingActive) return;
        const id = safeCursorId(name);
        let cursor = document.getElementById(id);
        if (!cursor) {
          cursor = document.createElement('div');
          cursor.id = id;
          cursor.className = 'peer-cursor';
          cursor.textContent = String(name || 'peer');
          els.canvasContainer.appendChild(cursor);
        }
        cursor.style.left = (x * 100) + '%';
        cursor.style.top = (y * 100) + '%';
      }

      function sendImageAsFile(base64, name) {
        const chat = getActiveChat();
        if (!chat) return;

        const meta = { name: name, size: 'Unknown', type: 'image/png', hash: 'generated' };
        const payload = { type: 'file', content: base64, meta: meta, ghost: ghostMode };
        const timestamp = new Date().toISOString();
        const msgId = 'msg-' + Math.random().toString(36).slice(2, 11);

        const msgObj = { id: msgId, chatId: chat.id, from: 'me', type: 'file', content: base64, meta: meta, timestamp: timestamp, ghost: ghostMode, status: 'pending', progress: 0 };
        chat.messages.push(msgObj);
        saveMessageToDB(msgObj);
        appendMessageToUI(msgObj);

        encryptPayload(chat.passphrase, payload).then(pkg => {
          sendFileChunked(chat, pkg, timestamp, msgObj);
        });
      }

      // --- FILE HANDLING (CHUNKED) ---
      async function handleFileUpload(e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
        const fileHash = buf2hex(hashBuffer);

        const reader = new FileReader();
        reader.onload = (ev) => {
          const base64 = ev.target.result;
          const chat = getActiveChat();
          if (!chat) return;

          const meta = {
            name: file.name,
            size: formatBytes(file.size),
            type: file.type || 'application/octet-stream',
            hash: fileHash
          };

          const payload = { type: 'file', content: base64, meta: meta, ghost: ghostMode };
          const timestamp = new Date().toISOString();
          const msgId = 'msg-' + Math.random().toString(36).slice(2, 11);

          const msgObj = {
            id: msgId,
            chatId: chat.id,
            from: 'me',
            type: 'file',
            content: base64,
            meta: meta,
            timestamp: timestamp,
            ghost: ghostMode,
            status: 'pending',
            progress: 0
          };

          chat.messages.push(msgObj);
          saveMessageToDB(msgObj);
          appendMessageToUI(msgObj);

          encryptPayload(chat.passphrase, payload).then(pkg => {
            sendFileChunked(chat, pkg, timestamp, msgObj);
          });
        };
        reader.readAsDataURL(file);
        e.target.value = '';
      }

      function sendFileChunked(chat, pkg, timestamp, msgObj) {
        const fullData = JSON.stringify(pkg);
        const totalSize = fullData.length;
        const totalChunks = Math.ceil(totalSize / CHUNK_SIZE);
        const fileId = 'f-' + Date.now() + '-' + Math.random().toString(36).slice(2, 7);

        let currentChunk = 0;

        const sendNextChunk = () => {
          if (currentChunk >= totalChunks) {
            msgObj.status = 'sent';
            msgObj.progress = 100;
            updateProgressUI(msgObj);
            return;
          }

          // Backpressure control
          const dc = (chat.type === 'direct' && chat.conn) ? (chat.conn._dc || chat.conn.dataChannel) : null;
          if (dc && typeof dc.bufferedAmount === 'number' && dc.bufferedAmount > 1024 * 1024) {
            setTimeout(sendNextChunk, 50);
            return;
          }

          const start = currentChunk * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, totalSize);
          const chunkData = fullData.substring(start, end);

          const chunkMsg = {
            kind: 'file_chunk',
            fileId: fileId,
            current: currentChunk,
            total: totalChunks,
            data: chunkData,
            timestamp: timestamp,
            senderName: myId,
            groupId: chat.type === 'group' ? chat.id : undefined,
            groupName: chat.type === 'group' ? chat.name : undefined
          };

          if (chat.type === 'direct') {
            if (chat.conn && chat.conn.open) chat.conn.send(chunkMsg);
            else {
              // Queue file chunks is heavy; treat as failure
              msgObj.status = 'failed';
              updateProgressUI(msgObj);
              return;
            }
          } else {
            chat.participants.forEach(pid => {
              const c = chat.connections[pid];
              if (c && c.open) c.send(chunkMsg);
            });
          }

          currentChunk++;
          msgObj.progress = Math.floor((currentChunk / totalChunks) * 100);
          updateProgressUI(msgObj);

          setTimeout(sendNextChunk, 5);
        };

        sendNextChunk();
      }

      function handleFileChunk(chat, data) {
        if (!settings.allowFiles) {
          sendSignal(chat, { type: 'file_rejected' });
          return;
        }

        if (!incomingFiles[chat.id]) incomingFiles[chat.id] = {};

        if (!incomingFiles[chat.id][data.fileId]) {
          incomingFiles[chat.id][data.fileId] = {
            chunks: [],
            receivedCount: 0,
            totalChunks: data.total,
            timestamp: data.timestamp,
            senderName: data.senderName,
            msgObj: null
          };

          const msgObj = {
            id: 'msg-' + Math.random().toString(36).slice(2, 11),
            chatId: chat.id,
            from: 'them',
            senderName: data.senderName,
            type: 'file_transfer',
            progress: 0,
            timestamp: data.timestamp,
            status: 'receiving'
          };
          incomingFiles[chat.id][data.fileId].msgObj = msgObj;
          chat.messages.push(msgObj);
          if (activeChatId === chat.id) appendMessageToUI(msgObj);
        }

        const fileData = incomingFiles[chat.id][data.fileId];
        fileData.chunks[data.current] = data.data;
        fileData.receivedCount++;

        fileData.msgObj.progress = Math.floor((fileData.receivedCount / fileData.totalChunks) * 100);
        if (activeChatId === chat.id) updateProgressUI(fileData.msgObj);

        if (fileData.receivedCount === fileData.totalChunks) {
          const fullString = fileData.chunks.join('');
          try {
            const pkg = JSON.parse(fullString);
            decryptMessage(chat.passphrase, pkg).then(payload => {
              if (!payload) return;

              const finalMsg = fileData.msgObj;
              finalMsg.type = payload.type;
              finalMsg.content = payload.content;
              finalMsg.meta = payload.meta;
              finalMsg.ghost = payload.ghost;
              finalMsg.status = 'received';

              saveMessageToDB(finalMsg);
              delete incomingFiles[chat.id][data.fileId];
              if (activeChatId === chat.id) renderMessages(chat);
            });
          } catch(e) { console.error("Reassembly failed", e); }
        }
      }

      function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      }

      // --- CRYPTO ---
      async function encryptPayload(pass, payload) {
        const key = await getKey(pass);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const enc = new TextEncoder();
        const data = enc.encode(JSON.stringify(payload));
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, data);
        return { iv: buf2hex(iv), data: buf2hex(ciphertext) };
      }

      async function decryptMessage(passphrase, pkg) {
        try {
          const key = await getKey(passphrase);
          const iv = hex2buf(pkg.iv);
          const data = hex2buf(pkg.data);
          const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, data);
          const dec = new TextDecoder();
          return JSON.parse(dec.decode(decrypted));
        } catch(e) {
          return { type: 'text', content: 'üîí Decryption failed.' };
        }
      }

      async function getKey(pass) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pass), { name: "PBKDF2" }, false, ["deriveKey"]);
        return crypto.subtle.deriveKey(
          { name: "PBKDF2", salt: enc.encode("pepechat_salt"), iterations: 100000, hash: "SHA-256" },
          keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
        );
      }

      // --- UI RENDERING ---
      function renderChatList() {
        els.chatList.innerHTML = '';
        chats.forEach(chat => {
          const div = document.createElement('div');
          div.className = `chat-item ${activeChatId === chat.id ? 'active' : ''}`;

          let statusClass = '';
          let statusText = 'Offline';

          if (chat.type === 'group') {
            statusClass = 'online';
            statusText = 'Group';
          } else {
            if (chat.conn && chat.conn.open) {
              statusClass = 'online';
              statusText = 'Online';
            } else if (chat.iceState === 'checking' || chat.dialInProgress) {
              statusClass = 'connecting';
              statusText = 'Connecting...';
            } else if (chat.iceState === 'failed') {
              statusClass = 'failed';
              statusText = 'Failed';
            }
          }

          div.innerHTML = `
            <div class="avatar">${sanitize(chat.name.substring(0,2).toUpperCase())}</div>
            <div style="flex:1; overflow:hidden;">
              <div style="display:flex; justify-content:space-between;">
                <span style="font-weight:600; font-size:14px;">${sanitize(chat.name)}</span>
                ${chat.unread > 0 ? `<span style="background:var(--danger); color:white; border-radius:10px; padding:0 6px; font-size:10px;">${chat.unread}</span>` : ''}
              </div>
              <div style="font-size:12px; color:var(--text-muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                ${sanitize(statusText)}
              </div>
            </div>
            <div class="status-dot ${statusClass}"></div>
          `;
          div.onclick = () => setActiveChat(chat.id);
          els.chatList.appendChild(div);
        });
      }

      function setActiveChat(id) {
        if (window.innerWidth <= 768) {
          els.sidebar.classList.remove('open');
          els.sidebarOverlay.classList.remove('visible');
        }

        activeChatId = id;
        const chat = chats.get(id);
        if (!chat) {
          els.chatTitle.textContent = "No Chat Selected";
          els.messages.innerHTML = '';
          return;
        }

        chat.unread = 0;
        els.chatTitle.textContent = chat.name;

        if (chat.type === 'group') {
          els.chatStatus.innerHTML = `<span style="color:var(--accent); cursor:pointer;" onclick="openModal(document.getElementById('groupAddMemberModal'))">+ Add Member</span>`;
          els.reconnectBtn.style.display = 'none';
        } else {
          updateChatStatus(chat);
        }

        renderMessages(chat);
        renderChatList();
      }

      function updateChatStatus(chat) {
        if (!chat || activeChatId !== chat.id || chat.type === 'group') return;

        let text = "Offline";
        let color = "var(--text-muted)";
        let showReconnect = false;

        if (chat.conn && chat.conn.open) {
          text = "Online ¬∑ Encrypted";
          color = "var(--success)";
        } else if (chat.iceState === 'checking' || chat.dialInProgress) {
          text = "Connecting (ICE)...";
          color = "var(--warning)";
        } else if (chat.iceState === 'failed') {
          text = "Connection Failed (NAT). TURN likely required.";
          color = "var(--danger)";
          showReconnect = true;
        }

        els.chatStatus.textContent = text;
        els.chatStatus.style.color = color;
        els.reconnectBtn.style.display = showReconnect ? 'block' : 'none';
      }

      function renderMessages(chat) {
        els.messages.innerHTML = '';
        (chat.messages || []).forEach(appendMessageToUI);
        els.messages.scrollTop = els.messages.scrollHeight;
      }

      function appendMessageToUI(msg) {
        const div = document.createElement('div');

        if (msg.from === 'system') {
          div.className = 'msg system';
          div.textContent = msg.content;
          els.messages.appendChild(div);
          return;
        }

        div.className = `msg ${msg.from === 'me' ? 'out' : 'in'} ${msg.ghost ? 'ghost-fade' : ''}`;

        if (!msg.id) msg.id = 'msg-' + Math.random().toString(36).slice(2, 11);
        div.id = msg.id;

        let contentHtml = '';

        if (msg.type === 'text') {
          contentHtml = `<div style="white-space:pre-wrap;">${sanitize(msg.content)}</div>`;
        } else if (msg.type === 'audio') {
          const audioId = 'audio-' + msg.id;
          contentHtml = `
            <div class="audio-visualizer" id="${audioId}">
              <i class="fa-solid fa-play play-icon" onclick="playAudioMsg('${msg.content}', '${audioId}')"></i>
              <canvas class="waveform-canvas"></canvas>
            </div>
          `;
          setTimeout(() => drawWaveform(msg.content, audioId), 100);
        } else if (msg.type === 'morse') {
          const seqStr = JSON.stringify(msg.content);
          contentHtml = `
            <div style="display:flex; align-items:center; gap:10px;">
              <i class="fa-solid fa-teletype"></i>
              <span>Morse Sequence (${(msg.content || []).length} taps)</span>
              <i class="fa-solid fa-play play-icon" onclick='playMorseSequence(${seqStr})'></i>
            </div>
          `;
        } else if (msg.type === 'file') {
          const fileId = 'file-' + Math.random().toString(36).slice(2, 11);
          window[fileId] = { content: msg.content, meta: msg.meta };

          const isImg = msg.meta && msg.meta.type && msg.meta.type.startsWith('image/');

          contentHtml = `
            <div class="file-card">
              <div class="file-header">
                <i class="fa-solid ${isImg ? 'fa-image' : 'fa-file'}"></i>
                <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${sanitize(msg.meta ? msg.meta.name : 'file')}</span>
                <i class="fa-solid fa-circle-info file-info-icon" onclick="showFileInfo('${fileId}')"></i>
              </div>
              <div style="font-size:10px; color:#aaa;">${sanitize((msg.meta && msg.meta.size) ? msg.meta.size : '')}</div>
              <div class="file-actions">
                ${isImg ? `<button class="file-btn-small" onclick="previewFile('${fileId}')"><i class="fa-solid fa-eye"></i> Preview</button>` : ''}
                <button class="file-btn-small" onclick="downloadFile('${fileId}')"><i class="fa-solid fa-download"></i> Download</button>
              </div>
              <div id="preview-${fileId}" style="display:none; margin-top:5px;"></div>
            </div>
          `;
        } else if (msg.type === 'file_transfer') {
          contentHtml = `
            <div class="file-card">
              <div class="file-header">
                <i class="fa-solid fa-spinner fa-spin"></i>
                <span>Receiving File...</span>
              </div>
              <div class="progress-track"><div class="progress-fill" style="width: ${msg.progress}%"></div></div>
            </div>
          `;
        }

        if (msg.from === 'me' && msg.status === 'pending' && (msg.type === 'file' || msg.type === 'audio')) {
          contentHtml += `<div class="progress-track"><div class="progress-fill" style="width: ${msg.progress || 0}%"></div></div>`;
        }

        const senderInfo = (msg.from === 'them' && msg.senderName)
          ? `<div style="font-size:10px; color:var(--accent); margin-bottom:2px;">${sanitize(msg.senderName)}</div>`
          : '';

        let statusIcon = '';
        if (msg.from === 'me') {
          if (msg.status === 'pending') statusIcon = '<i class="fa-regular fa-clock"></i>';
          else if (msg.status === 'sent') statusIcon = '<i class="fa-solid fa-check"></i>';
          else if (msg.status === 'failed') statusIcon = '<i class="fa-solid fa-circle-exclamation" style="color:red"></i>';
        }

        const copyBtn = msg.type === 'text'
          ? `<i class="fa-regular fa-copy copy-btn" onclick="copyToClipboard('${msg.id}')" title="Copy Text"></i>`
          : '';

        div.innerHTML = `
          ${senderInfo}
          ${contentHtml}
          <div class="msg-meta">
            ${copyBtn}
            ${msg.ghost ? 'üëª ' : ''}
            <span class="msg-status">${statusIcon}</span>
            ${new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
          </div>
        `;

        els.messages.appendChild(div);
        els.messages.scrollTop = els.messages.scrollHeight;

        if (msg.ghost) {
          setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 30000);
        }
      }

      function updateProgressUI(msg) {
        const el = document.getElementById(msg.id);
        if (!el) return;
        const bar = el.querySelector('.progress-fill');
        if (bar) bar.style.width = (msg.progress || 0) + '%';

        if (msg.status === 'sent' && msg.from === 'me') {
          setTimeout(() => {
            const track = el.querySelector('.progress-track');
            if (track) track.style.display = 'none';
            const status = el.querySelector('.msg-status');
            if (status) status.innerHTML = '<i class="fa-solid fa-check"></i>';
          }, 500);
        }
        if (msg.status === 'failed' && msg.from === 'me') {
          const status = el.querySelector('.msg-status');
          if (status) status.innerHTML = '<i class="fa-solid fa-circle-exclamation" style="color:red"></i>';
        }
      }

      // --- AUDIO VISUALIZER ---
      window.playAudioMsg = (src, containerId) => {
        const audio = new Audio(src);
        const container = document.getElementById(containerId);
        if (!container) return;
        const icon = container.querySelector('.play-icon');

        icon.className = "fa-solid fa-stop play-icon";
        icon.onclick = () => { audio.pause(); audio.currentTime = 0; };

        audio.play();
        audio.onended = () => {
          icon.className = "fa-solid fa-play play-icon";
          icon.onclick = () => playAudioMsg(src, containerId);
        };
      };

      function drawWaveform(src, containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        const canvas = container.querySelector('canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#0A84FF';
        const bars = 30;
        const gap = 2;
        const width = (canvas.width / bars) - gap;

        for (let i=0; i<bars; i++) {
          const height = Math.random() * canvas.height * 0.8;
          const y = (canvas.height - height) / 2;
          ctx.fillRect(i * (width + gap), y, width, height);
        }
      }

      window.copyToClipboard = async (msgId) => {
        const el = document.getElementById(msgId);
        if (!el) return;
        const clone = el.cloneNode(true);
        const meta = clone.querySelector('.msg-meta');
        if (meta) meta.remove();

        const text = (clone.innerText || '').trim();
        await safeCopyText(text);

        const btn = el.querySelector('.copy-btn');
        if (btn) {
          btn.classList.remove('fa-copy');
          btn.classList.add('fa-check');
          setTimeout(() => {
            btn.classList.remove('fa-check');
            btn.classList.add('fa-copy');
          }, 1000);
        }
      };

      // --- FILE ACTIONS ---
      window.showFileInfo = (fileId) => {
        const data = window[fileId];
        if (!data) return;
        els.fiName.textContent = data.meta.name || '';
        els.fiType.textContent = data.meta.type || '';
        els.fiSize.textContent = data.meta.size || '';
        els.fiHash.textContent = data.meta.hash || '';
        openModal(els.fileInfoModal);
      };

      window.previewFile = (fileId) => {
        const data = window[fileId];
        const container = document.getElementById('preview-' + fileId);
        if (!data || !container) return;

        if (container.style.display === 'none') {
          container.innerHTML = `<img src="${data.content}" style="width:100%; border-radius:8px;">`;
          container.style.display = 'block';
        } else {
          container.style.display = 'none';
        }
      };

      window.downloadFile = (fileId) => {
        const data = window[fileId];
        if (!data) return;
        const a = document.createElement('a');
        a.href = data.content;
        a.download = (data.meta && data.meta.name) ? data.meta.name : 'download';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };

      function addSystemMessage(chat, text) {
        if (!chat) return;
        const msg = { id: 'sys-' + Math.random().toString(36).slice(2, 11), chatId: chat.id, from: 'system', type: 'text', content: text, timestamp: new Date().toISOString() };
        chat.messages.push(msg);
        if (activeChatId === chat.id) appendMessageToUI(msg);
      }

      // --- VIRTUAL KEYBOARD (FIX: previously missing/unstable) ---
      function renderVk() {
        const sets = {
          abc: [
            ..."qwertyuiop",
            ..."asdfghjkl",
            ..."zxcvbnm"
          ],
          "123": [
            ..."1234567890",
            ..."@#$_&-+()",
            ..."*/\"'?:;!"
          ],
          sym: [
            ..."[]{}<>|\\^~",
            ..."=:%`.,",
            ..."‚Ç¨¬£¬•‚Ä¢‚Ä¶‚Äî"
          ],
          emo: [
            "üòÄ","üòÇ","üòç","üòé","üò≠","üò°","üëç","üôè","üî•","üíØ",
            "üéâ","‚úÖ","‚ùå","‚ö†Ô∏è","üîí","üß†","üõ∞Ô∏è","üìé","üñºÔ∏è","üéôÔ∏è",
            "üëª","üï≥Ô∏è","üß±","üß™","üß∑","üß®","üß≠","üìå","üì°","üßæ"
          ]
        };

        let keys = (sets[vkSet] || sets.abc).slice();

        if (vkScramble) keys = shuffle(keys);

        els.vkKeys.innerHTML = '';

        const addKey = (label, value, cls = '') => {
          const k = document.createElement('div');
          k.className = `vk-key ${cls}`.trim();
          k.textContent = label;
          k.addEventListener('click', () => handleVkKey(value));
          els.vkKeys.appendChild(k);
        };

        // Row keys
        keys.forEach(ch => addKey(ch, ch));

        // Controls
        addKey("‚üµ", "LEFT", "arrow wide");
        addKey("‚ü∂", "RIGHT", "arrow wide");
        addKey("‚å´", "BACK", "wide");
        addKey("SPACE", " ", "space");
        addKey("‚èé", "ENTER", "wide");
      }

      function handleVkKey(value) {
        const input = els.msgInput;
        input.focus();

        if (value === "BACK") {
          const start = input.selectionStart || 0;
          const end = input.selectionEnd || 0;
          if (start === end && start > 0) {
            input.value = input.value.slice(0, start - 1) + input.value.slice(end);
            input.setSelectionRange(start - 1, start - 1);
          } else {
            input.value = input.value.slice(0, start) + input.value.slice(end);
            input.setSelectionRange(start, start);
          }
          return;
        }

        if (value === "LEFT") {
          const pos = Math.max(0, (input.selectionStart || 0) - 1);
          input.setSelectionRange(pos, pos);
          return;
        }
        if (value === "RIGHT") {
          const pos = Math.min(input.value.length, (input.selectionStart || 0) + 1);
          input.setSelectionRange(pos, pos);
          return;
        }

        if (value === "ENTER") {
          sendMessage();
          return;
        }

        const start = input.selectionStart || 0;
        const end = input.selectionEnd || 0;
        input.value = input.value.slice(0, start) + value + input.value.slice(end);
        const newPos = start + String(value).length;
        input.setSelectionRange(newPos, newPos);
      }

      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      // --- HELPERS ---
      function sanitize(str) {
        const temp = document.createElement('div');
        temp.textContent = String(str ?? '');
        return temp.innerHTML;
      }

      window.openModal = (el) => { if (el) el.classList.add('open'); };
      window.closeModals = () => { document.querySelectorAll('.modal-overlay').forEach(el => el.classList.remove('open')); };

      async function safeCopyText(text) {
        const t = String(text || '');
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(t);
            return true;
          }
        } catch {}
        try {
          const ta = document.createElement('textarea');
          ta.value = t;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          return true;
        } catch {}
        return false;
      }

      function showQrModal() {
        if (!myId) return;

        // Use active chat key if direct chat selected; otherwise use default key.
        const chat = getActiveChat();
        const key = (chat && chat.type === 'direct' && chat.passphrase) ? chat.passphrase : (settings.defaultPassphrase || 'changeme');
        const encodedKey = encodeURIComponent(b64urlEncodeUtf8(key));
        const url = `${APP_URL}?connect=${encodeURIComponent(myId)}&key=${encodedKey}`;

        openModal(els.qrModal);
        setTimeout(() => {
          els.qrCanvas.innerHTML = '';
          new QRCode(els.qrCanvas, { text: url, width: 200, height: 200 });
          els.shareUrlInput.value = url;
        }, 60);
      }

      function normalizePeerId(id) {
        if (!id) return '';
        let s = String(id).trim();
        s = s.replace(/^ID:\s*/i, '');
        s = s.replace(/\s+/g, '');
        s = s.replace(/[^a-zA-Z0-9-_]/g, '');
        return s;
      }

      function generateRandomId() { return 'user-' + Math.floor(Math.random() * 100000); }

      function buf2hex(buffer) {
        const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
        return Array.prototype.map.call(bytes, x => ('00' + x.toString(16)).slice(-2)).join('');
      }
      function hex2buf(hex) {
        const clean = String(hex || '').replace(/[^0-9a-f]/gi, '');
        const out = new Uint8Array((clean.length / 2) | 0);
        for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.substr(i * 2, 2), 16);
        return out;
      }

      function saveStorage() {
        const chatsArr = Array.from(chats.entries()).map(([k, v]) => {
          const { conn, connections, messages, pendingMessages, ...rest } = v;
          return [k, rest];
        });
        const data = { myId, chats: chatsArr, settings, activeChatId };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      }

      async function loadStorageAsync() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          // Defaults into UI
          els.secureSessionToggle.checked = settings.secureSession;
          els.allowFilesToggle.checked = settings.allowFiles;
          els.useOpenRelayToggle.checked = settings.useOpenRelay;
          els.forceRelayToggle.checked = settings.forceRelay;
          return;
        }

        try {
          const data = JSON.parse(raw);

          if (data.settings) {
            settings = { ...settings, ...data.settings };
          }

          els.secureSessionToggle.checked = !!settings.secureSession;
          els.allowFilesToggle.checked = settings.allowFiles !== false;
          els.useOpenRelayToggle.checked = settings.useOpenRelay !== false;
          els.forceRelayToggle.checked = !!settings.forceRelay;

          if (settings.turnUrl) els.turnUrlInput.value = settings.turnUrl;
          if (settings.turnUser) els.turnUserInput.value = settings.turnUser;
          if (settings.turnPass) els.turnPassInput.value = settings.turnPass;

          if (data.chats && Array.isArray(data.chats)) {
            const restored = new Map();
            for (const pair of data.chats) {
              if (!Array.isArray(pair) || pair.length < 2) continue;
              const key = pair[0];
              const val = pair[1] || {};
              restored.set(key, { ...val });
            }
            chats = restored;

            for (const chat of chats.values()) {
              chat.conn = null;
              chat.connections = {};
              chat.unread = 0;
              chat.pendingMessages = [];
              chat.lastSeen = 0;
              chat.iceState = 'new';
              chat.dialInProgress = false;
              chat.__retryCount = 0;
              chat.passphrase = chat.passphrase || settings.defaultPassphrase || 'changeme';
              chat.messages = await loadMessagesFromDB(chat.id);
            }
          }

          if (data.activeChatId && chats.has(data.activeChatId)) {
            activeChatId = data.activeChatId;
            setTimeout(() => setActiveChat(activeChatId), 0);
          }
        } catch(e) {
          console.warn("Storage parse failed", e);
        }
      }

      function getActiveChat() {
        return activeChatId ? chats.get(activeChatId) : null;
      }

    })();
  </script>
</body>
</html>
